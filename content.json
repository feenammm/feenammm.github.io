{"meta":{"title":"阿巴巴巴","subtitle":null,"description":null,"author":"wxy","url":"http://wajj.xin","root":"/"},"pages":[{"title":"友情链接","date":"2021-04-15T01:22:16.594Z","updated":"2021-04-14T15:47:20.000Z","comments":true,"path":"links/index.html","permalink":"http://wajj.xin/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-04-15T01:22:16.599Z","updated":"2021-04-14T15:47:20.000Z","comments":false,"path":"tags/index.html","permalink":"http://wajj.xin/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-04-15T01:22:16.588Z","updated":"2021-04-14T15:47:20.000Z","comments":false,"path":"categories/index.html","permalink":"http://wajj.xin/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-04-15T01:22:16.596Z","updated":"2021-04-14T15:47:20.000Z","comments":false,"path":"repository/index.html","permalink":"http://wajj.xin/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"Quartz","slug":"java/Quartz/Quartz","date":"2021-04-19T07:24:46.000Z","updated":"2021-04-21T03:19:38.453Z","comments":true,"path":"2021/04/19/java/Quartz/Quartz/","link":"","permalink":"http://wajj.xin/2021/04/19/java/Quartz/Quartz/","excerpt":"","text":"(乱七八糟的复制) Quartz简介Quartz是OpenSymphony开源组织在Job scheduling领域又一个开源项目，是完全由java开发的一个开源的任务日程管理系统，“任务进度管理器”就是一个在预先确定（被纳入日程）的时间到达时，负责执行（或者通知）其他软件组件的系统。这些功能的主要接口(API)是Scheduler接口。它提供了简单的操作，例如：将任务纳入日程或者从日程中取消，开始/停止/暂停日程进度。 定时器种类Quartz 中五种类型的 Trigger：SimpleTrigger，CronTirgger，DateIntervalTrigger，NthIncludedDayTrigger和Calendar 类。最常用的：SimpleTrigger：用来触发只需执行一次或者在给定时间触发并且重复N次且每次执行延迟一定时间的任务CronTrigger：按照cron表达式触发calendars 方式：可以和cron配合使用，用cron表达式指定一个触发时间规律，用calendar指定一个范围 存储方式 类型 优点 缺点 RAMJobStore本地运行 不要外部数据库，配置容易，运行速度快 因为调度程序信息是存储在被分配给JVM的内存里面，所以，当应用程序停止运行时，所有调度信息将被丢失。另外因为存储到JVM内存里面，所以可以存储多少个Job和Trigger将会受到限制 JDBCJobStore使用数据库 支持集群，因为所有的任务信息都会保存到数据库中，可以控制事物，还有就是如果应用服务器关闭或者重启，任务信息都不会丢失，并且可以恢复因服务器关闭或者重启而导致执行失败的任务 运行速度的快慢取决与连接数据库的快慢 表关系 表名 存放数据 qrtz_blob_triggers 以Blob 类型存储的触发器 qrtz_calendars 存放日历信息，quartz可配置一个日历来指定一个时间范围 qrtz_cron_triggers 存放cron类型的触发器 qrtz_fired_triggers 存放已触发的触发器 qrtz_job_details 存放一个jobDetail信息 qrtz_job_listeners job监听器 qrtz_locks 存储程序的悲观锁的信息(假如使用了悲观锁) qrtz_paused_trigger_graps 存放暂停掉的触发器 qrtz_scheduler_state 调度器状态 qrtz_simple_triggers 简单触发器的信息 qrtz_trigger_listeners 触发器监听器 qrtz_triggers 触发器的基本信息 cron方式需要用到的4张数据表： 1qrtz_triggers，qrtz_cron_triggers，qrtz_fired_triggers，qrtz_job_details 字段详解qrtz_blob_triggers自定义触发器表 123456789CREATE TABLE `qrtz_blob_triggers` ( `SCHED_NAME` varchar(120) NOT NULL COMMENT &#x27;计划名称&#x27;, `TRIGGER_NAME` varchar(200) NOT NULL COMMENT &#x27;触发器名称&#x27;, `TRIGGER_GROUP` varchar(200) NOT NULL COMMENT &#x27;触发器群组&#x27;, `BLOB_DATA` blob COMMENT &#x27;基本信息&#x27;, PRIMARY KEY (`SCHED_NAME`,`TRIGGER_NAME`,`TRIGGER_GROUP`), KEY `SCHED_NAME` (`SCHED_NAME`,`TRIGGER_NAME`,`TRIGGER_GROUP`), CONSTRAINT `qrtz_blob_triggers_ibfk_1` FOREIGN KEY (`SCHED_NAME`, `TRIGGER_NAME`, `TRIGGER_GROUP`) REFERENCES `qrtz_triggers` (`SCHED_NAME`, `TRIGGER_NAME`, `TRIGGER_GROUP`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;用于 Quartz 用户用 JDBC 创建他们自己定制的 Trigger 类型，JobStore并不知道如何存储实例的时候&#x27;; qrtz_calendars日历信息触发器 123456CREATE TABLE `qrtz_calendars` ( `SCHED_NAME` varchar(120) NOT NULL COMMENT &#x27;计划名称&#x27;, `CALENDAR_NAME` varchar(200) NOT NULL COMMENT &#x27;触发器名称&#x27;, `CALENDAR` blob NOT NULL COMMENT &#x27;日历信息&#x27;, PRIMARY KEY (`SCHED_NAME`,`CALENDAR_NAME`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;日历信息触发器&#x27;; qrtz_cron_triggerscron 表达式触发器 123456789CREATE TABLE `qrtz_cron_triggers` ( `SCHED_NAME` varchar(120) NOT NULL COMMENT &#x27;计划名称&#x27;, `TRIGGER_NAME` varchar(200) NOT NULL COMMENT &#x27;触发器名称&#x27;, `TRIGGER_GROUP` varchar(200) NOT NULL COMMENT &#x27;触发器群组&#x27;, `CRON_EXPRESSION` varchar(120) NOT NULL COMMENT &#x27;cron表达式&#x27;, `TIME_ZONE_ID` varchar(80) DEFAULT NULL COMMENT &#x27;时区&#x27;, PRIMARY KEY (`SCHED_NAME`,`TRIGGER_NAME`,`TRIGGER_GROUP`), CONSTRAINT `qrtz_cron_triggers_ibfk_1` FOREIGN KEY (`SCHED_NAME`, `TRIGGER_NAME`, `TRIGGER_GROUP`) REFERENCES `qrtz_triggers` (`SCHED_NAME`, `TRIGGER_NAME`, `TRIGGER_GROUP`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;cron触发器&#x27;; qrtz_fired_triggers已触发的触发器 12345678910111213141516171819202122CREATE TABLE `qrtz_fired_triggers` ( `SCHED_NAME` varchar(120) NOT NULL COMMENT &#x27;计划名称&#x27;, `ENTRY_ID` varchar(95) NOT NULL COMMENT &#x27;组织id&#x27;, `TRIGGER_NAME` varchar(200) NOT NULL COMMENT &#x27;触发器名称&#x27;, `TRIGGER_GROUP` varchar(200) NOT NULL COMMENT &#x27;触发器组&#x27;, `INSTANCE_NAME` varchar(200) NOT NULL COMMENT &#x27;实例名称&#x27;, `FIRED_TIME` bigint(13) NOT NULL COMMENT &#x27;触发时间&#x27;, `SCHED_TIME` bigint(13) NOT NULL COMMENT &#x27;计划时间&#x27;, `PRIORITY` int(11) NOT NULL COMMENT &#x27;权重&#x27;, `STATE` varchar(16) NOT NULL COMMENT &#x27;状态&#x27;, `JOB_NAME` varchar(200) DEFAULT NULL COMMENT &#x27;作业名称&#x27;, `JOB_GROUP` varchar(200) DEFAULT NULL COMMENT &#x27;作业群组&#x27;, `IS_NONCONCURRENT` varchar(1) DEFAULT NULL COMMENT &#x27;是否并行&#x27;, `REQUESTS_RECOVERY` varchar(1) DEFAULT NULL COMMENT &#x27;是否要求唤醒&#x27;, PRIMARY KEY (`SCHED_NAME`,`ENTRY_ID`), KEY `IDX_QRTZ_FT_TRIG_INST_NAME` (`SCHED_NAME`,`INSTANCE_NAME`), KEY `IDX_QRTZ_FT_INST_JOB_REQ_RCVRY` (`SCHED_NAME`,`INSTANCE_NAME`,`REQUESTS_RECOVERY`), KEY `IDX_QRTZ_FT_J_G` (`SCHED_NAME`,`JOB_NAME`,`JOB_GROUP`), KEY `IDX_QRTZ_FT_JG` (`SCHED_NAME`,`JOB_GROUP`), KEY `IDX_QRTZ_FT_T_G` (`SCHED_NAME`,`TRIGGER_NAME`,`TRIGGER_GROUP`), KEY `IDX_QRTZ_FT_TG` (`SCHED_NAME`,`TRIGGER_GROUP`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;存储与已触发的 Trigger 相关的状态信息，以及相联 Job的执行信息QRTZ_PAUSED_TRIGGER_GRPS 存储已暂停的 Trigger组的信息&#x27;; qrtz_job_details123456789101112131415CREATE TABLE `qrtz_job_details` ( `SCHED_NAME` varchar(120) NOT NULL COMMENT &#x27;调度器名称&#x27;, `JOB_NAME` varchar(200) NOT NULL COMMENT &#x27;任务名称&#x27;, `JOB_GROUP` varchar(200) NOT NULL COMMENT &#x27;任务群组&#x27;, `DESCRIPTION` varchar(250) DEFAULT NULL COMMENT &#x27;说明&#x27;, `JOB_CLASS_NAME` varchar(250) NOT NULL COMMENT &#x27;任务class全路径&#x27;, `IS_DURABLE` varchar(1) NOT NULL COMMENT &#x27;是否持久化,值为1会把job持久化到数据库中&#x27;, `IS_NONCONCURRENT` varchar(1) NOT NULL COMMENT &#x27;是否并行&#x27;, `IS_UPDATE_DATA` varchar(1) NOT NULL, `REQUESTS_RECOVERY` varchar(1) NOT NULL COMMENT &#x27;是否要求唤醒&#x27;, `JOB_DATA` blob, PRIMARY KEY (`SCHED_NAME`,`JOB_NAME`,`JOB_GROUP`), KEY `IDX_QRTZ_J_REQ_RECOVERY` (`SCHED_NAME`,`REQUESTS_RECOVERY`), KEY `IDX_QRTZ_J_GRP` (`SCHED_NAME`,`JOB_GROUP`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; qrtz_locks在集群模式下，通过悲观锁来保证触发器有序的获取。 12345CREATE TABLE `qrtz_locks` ( `SCHED_NAME` varchar(120) NOT NULL COMMENT &#x27;计划名称&#x27;, `LOCK_NAME` varchar(40) NOT NULL COMMENT &#x27;锁名称&#x27;, PRIMARY KEY (`SCHED_NAME`,`LOCK_NAME`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;通过悲观锁获取触发器&#x27;; qrtz_paused_trigger_grps12345CREATE TABLE `qrtz_paused_trigger_grps` ( `SCHED_NAME` varchar(120) NOT NULL COMMENT &#x27;计划名称&#x27;, `TRIGGER_GROUP` varchar(200) NOT NULL COMMENT &#x27;触发器组&#x27;, PRIMARY KEY (`SCHED_NAME`,`TRIGGER_GROUP`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;被暂停的触发器&#x27;; qrtz_scheduler_state1234567CREATE TABLE `qrtz_scheduler_state` ( `SCHED_NAME` varchar(120) NOT NULL COMMENT &#x27;调度器名称&#x27;, `INSTANCE_NAME` varchar(200) NOT NULL, `LAST_CHECKIN_TIME` bigint(13) NOT NULL COMMENT &#x27;最后验证时间&#x27;, `CHECKIN_INTERVAL` bigint(13) NOT NULL COMMENT &#x27;时间间隔&#x27;, PRIMARY KEY (`SCHED_NAME`,`INSTANCE_NAME`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; qrtz_simple_triggers12345678910CREATE TABLE `qrtz_simple_triggers` ( `SCHED_NAME` varchar(120) NOT NULL COMMENT &#x27;计划名称&#x27;, `TRIGGER_NAME` varchar(200) NOT NULL COMMENT &#x27;触发器名称&#x27;, `TRIGGER_GROUP` varchar(200) NOT NULL COMMENT &#x27;触发器组&#x27;, `REPEAT_COUNT` bigint(7) NOT NULL COMMENT &#x27;重复次数&#x27;, `REPEAT_INTERVAL` bigint(12) NOT NULL COMMENT &#x27;重复间隔&#x27;, `TIMES_TRIGGERED` bigint(10) NOT NULL COMMENT &#x27;触发次数&#x27;, PRIMARY KEY (`SCHED_NAME`,`TRIGGER_NAME`,`TRIGGER_GROUP`), CONSTRAINT `qrtz_simple_triggers_ibfk_1` FOREIGN KEY (`SCHED_NAME`, `TRIGGER_NAME`, `TRIGGER_GROUP`) REFERENCES `qrtz_triggers` (`SCHED_NAME`, `TRIGGER_NAME`, `TRIGGER_GROUP`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;存储简单的Trigger，包括重复次数，间隔，以及已触的次数&#x27;; qrtz_triggers1234567891011121314151617181920212223242526272829303132CREATE TABLE `qrtz_triggers` ( `SCHED_NAME` varchar(120) NOT NULL COMMENT &#x27;计划名称&#x27;, `TRIGGER_NAME` varchar(200) NOT NULL COMMENT &#x27;触发器名称&#x27;, `TRIGGER_GROUP` varchar(200) NOT NULL COMMENT &#x27;触发器群组&#x27;, `JOB_NAME` varchar(200) NOT NULL COMMENT &#x27;作业名称&#x27;, `JOB_GROUP` varchar(200) NOT NULL COMMENT &#x27;作业群组&#x27;, `DESCRIPTION` varchar(250) DEFAULT NULL COMMENT &#x27;说明信息&#x27;, `NEXT_FIRE_TIME` bigint(13) DEFAULT NULL COMMENT &#x27;下次执行时间&#x27;, `PREV_FIRE_TIME` bigint(13) DEFAULT NULL COMMENT &#x27;上次执行时间&#x27;, `PRIORITY` int(11) DEFAULT NULL COMMENT &#x27;线程优先级&#x27;, `TRIGGER_STATE` varchar(16) NOT NULL COMMENT &#x27;触发状态此字段很重要&#x27;, `TRIGGER_TYPE` varchar(8) NOT NULL COMMENT &#x27;触发器类型&#x27;, `START_TIME` bigint(13) NOT NULL COMMENT &#x27;开始时间&#x27;, `END_TIME` bigint(13) DEFAULT NULL COMMENT &#x27;结束时间&#x27;, `CALENDAR_NAME` varchar(200) DEFAULT NULL COMMENT &#x27;日历名称&#x27;, `MISFIRE_INSTR` smallint(2) DEFAULT NULL, `JOB_DATA` blob, PRIMARY KEY (`SCHED_NAME`,`TRIGGER_NAME`,`TRIGGER_GROUP`), KEY `IDX_QRTZ_T_J` (`SCHED_NAME`,`JOB_NAME`,`JOB_GROUP`), KEY `IDX_QRTZ_T_JG` (`SCHED_NAME`,`JOB_GROUP`), KEY `IDX_QRTZ_T_C` (`SCHED_NAME`,`CALENDAR_NAME`), KEY `IDX_QRTZ_T_G` (`SCHED_NAME`,`TRIGGER_GROUP`), KEY `IDX_QRTZ_T_STATE` (`SCHED_NAME`,`TRIGGER_STATE`), KEY `IDX_QRTZ_T_N_STATE` (`SCHED_NAME`,`TRIGGER_NAME`,`TRIGGER_GROUP`,`TRIGGER_STATE`), KEY `IDX_QRTZ_T_N_G_STATE` (`SCHED_NAME`,`TRIGGER_GROUP`,`TRIGGER_STATE`), KEY `IDX_QRTZ_T_NEXT_FIRE_TIME` (`SCHED_NAME`,`NEXT_FIRE_TIME`), KEY `IDX_QRTZ_T_NFT_ST` (`SCHED_NAME`,`TRIGGER_STATE`,`NEXT_FIRE_TIME`), KEY `IDX_QRTZ_T_NFT_MISFIRE` (`SCHED_NAME`,`MISFIRE_INSTR`,`NEXT_FIRE_TIME`), KEY `IDX_QRTZ_T_NFT_ST_MISFIRE` (`SCHED_NAME`,`MISFIRE_INSTR`,`NEXT_FIRE_TIME`,`TRIGGER_STATE`), KEY `IDX_QRTZ_T_NFT_ST_MISFIRE_GRP` (`SCHED_NAME`,`MISFIRE_INSTR`,`NEXT_FIRE_TIME`,`TRIGGER_GROUP`,`TRIGGER_STATE`), CONSTRAINT `qrtz_triggers_ibfk_1` FOREIGN KEY (`SCHED_NAME`, `JOB_NAME`, `JOB_GROUP`) REFERENCES `qrtz_job_details` (`SCHED_NAME`, `JOB_NAME`, `JOB_GROUP`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;触发器和作业绑定&#x27;; quartz体系结构Quartz APIQuartz API的关键接口是： Scheduler - 与调度程序交互的主要API。可以注册Trigger和JobDetails到Scheduler中,当Trigger触发时，对应的Job就被执行 Job - 你想要调度器执行的任务组件需要实现的接口 JobDetail - 用于定义作业的实例。 Trigger（即触发器） - 定义执行给定作业的计划的触发条件。 JobBuilder - 用于定义/构建 JobDetail 实例，用于定义作业的实例。 TriggerBuilder - 用于定义/构建触发器实例。 Scheduler 的生命期，从 SchedulerFactory 创建它时开始，到 Scheduler 调用shutdown() 方法时结束；Scheduler 被创建后，可以增加、删除和列举 Job 和 Trigger，以及执行其它与调度相关的操作（如暂停 Trigger）。但是，Scheduler 只有在调用 start() 方法后，才会真正地触发 trigger（即执行 job） Job一个 job 就是一个实现了 Job 接口的类，该接口只有一个方法： 1234567package org.quartz;public interface Job &#123; public void execute(JobExecutionContext context) throws JobExecutionException;&#125; job的一个 trigger 被触发后，execute() 方法会被 scheduler 的一个工作线程调用；传递给 execute() 方法的 JobExecutionContext 对象中保存着该 job 运行时的一些信息 ，执行 job 的 scheduler 的引用，触发 job 的 trigger 的引用，JobDetail 对象引用，以及一些其它信息。 注解 @DisallowConcurrentExecution：将该注解加到job类上，告诉Quartz不要并发地执行同一个job定义（这里指特定的job类）的多个实例。 @PersistJobDataAfterExecution：将该注解加在job类上，告诉Quartz在成功执行了job类的execute方法后（没有发生任何异常），更新JobDetail中JobDataMap的数据，使得该job（即JobDetail）在下一次执行的时候，JobDataMap中是更新后的数据，而不是更新前的旧数据。 属性 Durability：如果一个job是非持久的，当没有活跃的trigger与之关联的时候，会被自动地从scheduler中删除。也就是说，非持久的job的生命期是由trigger的存在与否决定的； RequestsRecovery：如果一个job是可恢复的，并且在其执行的时候，scheduler发生硬关闭（hard shutdown)（比如运行的进程崩溃了，或者关机了），则当scheduler重新启动的时候，该job会被重新执行。此时，该job的JobExecutionContext.isRecovering() 返回true。 TriggerTrigger 用于触发 Job 的执行。当你准备调度一个 job 时，你创建一个 Trigger 的实例，然后设置调度相关的属性。Trigger 也有一个相关联的 JobDataMap，用于给 Job 传递一些触发相关的参数。Quartz 自带了各种不同类型的 Trigger，最常用的主要是 SimpleTrigger 和 CronTrigger。 一个Job可以对应多个Trigger，但一个Trigger只能对应一个Job。 当一个trigger被触发时，与之关联的JobDetail实例会被加载，JobDetail引用的job类通过配置在Scheduler上的JobFactory进行初始化。默认的JobFactory实现，仅仅是调用job类的newInstance()方法，然后尝试调用JobDataMap中的key的setter方法。 TRIGGER_STATE的值WAITING:等待 PAUSED:暂停 ACQUIRED:正常执行 BLOCKED：阻塞 ERROR：错误 错过触发MISFIRE_INSTR MisFire策略常量的定义在类CronTrigger中，列举如下： 常量值 含义 withMisfireHandlingInstructionDoNothing 不触发立即执行,等待下次Cron触发频率到达时刻开始按照Cron频率依次执行 withMisfireHandlingInstructionIgnoreMisfires 以错过的第一个频率时间立刻开始执行,重做错过的所有频率周期后,当下一次触发频率发生时间大于当前时间后，再按照正常的Cron频率依次执行 withMisfireHandlingInstructionFireAndProceed 以当前时间为触发频率立刻触发一次执行,然后按照Cron频率依次执行 公共属性 TriggerKey属性：表示trigger的身份 jobKey属性：当trigger触发时被执行的job的身份； startTime属性：设置trigger第一次触发的时间；该属性的值是java.util.Date类型，表示某个指定的时间点；有些类型的trigger，会在设置的startTime时立即触发，有些类型的trigger，表示其触发是在startTime之后开始生效。比如，现在是1月份，你设置了一个trigger–“在每个月的第5天执行”，然后你将startTime属性设置为4月1号，则该trigger第一次触发会是在几个月以后了(即4月5号)。 endTime属性：表示trigger失效的时间点。比如，”每月第5天执行”的trigger，如果其endTime是7月1号，则其最后一次执行时间是6月5号。 优先级 如果Quartz可能没有足够的资源同时触发所有的trigger,可以设置哪个trigger优先使用Quartz的工作线程，设置priority属性。比如，你有N个trigger需要同时触发，但只有Z个工作线程，优先级最高的Z个trigger会被首先触发。如果没有为trigger设置优先级，trigger使用默认优先级，值为5；priority属性的值可以是任意整数，正数、负数都可以。 注意：只有同时触发的trigger之间才会比较优先级。10:59触发的trigger总是在11:00触发的trigger之前执行。 注意：如果trigger是可恢复的，在恢复后再调度时，优先级与原trigger是一样的。 错过触发(misfire Instructions) trigger还有一个重要的属性misfire；如果scheduler关闭了，或者Quartz线程池中没有可用的线程来执行job，此时持久性的trigger就会错过(miss)其触发时间，即错过触发(misfire)。不同类型的trigger，有不同的misfire机制。它们默认都使用“智能机制(smart policy)”，即根据trigger的类型和配置动态调整行为。当scheduler启动的时候，查询所有错过触发(misfire)的持久性trigger。然后根据它们各自的misfire机制更新trigger的信息。 日历 Quartz的Calendar对象(不是java.util.Calendar对象)可以在定义和存储trigger的时候与trigger进行关联。Calendar用于从trigger的调度计划中排除时间段。 key将 Job 和 Trigger 注册到 Scheduler 时，可以为它们设置 key，配置其身份属性。 Job 和 Trigger 的 key（JobKey 和 TriggerKey）可以用于将 Job 和 Trigger 放到不同的分组（group）里，然后基于分组进行操作。同一个分组下的 Job 或 Trigger 的名称必须唯一，即一个 Job 或 Trigger 的 key 由名称（name）和分组（group）组成。 JobDataMapJobDataMap中可以包含不限量的（序列化的）数据对象，在job实例执行的时候，可以使用其中的数据 JobDataMap是Java Map接口的一个实现，额外增加了一些便于存取基本类型的数据的方法。 将job加入到scheduler之前，在构建JobDetail时，可以将数据放入JobDataMap 存 12345JobDetail job = newJob(DumbJob.class) .withIdentity(&quot;myJob&quot;, &quot;group1&quot;) // name &quot;myJob&quot;, group &quot;group1&quot; .usingJobData(&quot;jobSays&quot;, &quot;Hello World!&quot;) .usingJobData(&quot;myFloatValue&quot;, 3.141f) .build(); 取 123456789101112131415161718public class DumbJob implements Job &#123; public DumbJob() &#123; &#125; public void execute(JobExecutionContext context) throws JobExecutionException &#123; JobKey key = context.getJobDetail().getKey(); JobDataMap dataMap = context.getJobDetail().getJobDataMap(); String jobSays = dataMap.getString(&quot;jobSays&quot;); float myFloatValue = dataMap.getFloat(&quot;myFloatValue&quot;); System.err.println(&quot;Instance &quot; + key + &quot; of DumbJob says: &quot; + jobSays + &quot;, and val is: &quot; + myFloatValue); &#125;&#125; TriggerListeners和JobListenersListeners是用于根据调度程序中发生的事件执行操作 与Trigger相关的事件包括：触发器触发，触发失灵，触发完成 与job相关的事件包括：job即将执行的通知，以及job完成执行时的通知 使用Listeners 要创建一个listener，只需创建一个实现org.quartz.TriggerListener和/或org.quartz.JobListener接口的对象。然后，listener在运行时会向调度程序注册，并且必须给出一个名称（或者，他们必须通过他们的getName（）方法来宣传自己的名字）。 为了方便起见，实现这些接口，您的类也可以扩展JobListenerSupport类或TriggerListenerSupport类，并且只需覆盖您感兴趣的事件。 listener与调度程序的ListenerManager一起注册，并配有描述listener希望接收事件的job/触发器的Matcher。 添加对特定job感兴趣的JobListener： 1scheduler.getListenerManager().addJobListener(myJobListener，KeyMatcher.jobKeyEquals(new JobKey(&quot;myJobName&quot;，&quot;myJobGroup&quot;))); 添加对特定组的所有job感兴趣的JobListener： 1scheduler.getListenerManager().addJobListener(myJobListener, jobGroupEquals(&quot;myJobGroup&quot;)); 添加对两个特定组的所有job感兴趣的JobListener： 1scheduler.getListenerManager().addJobListener(myJobListener, or(jobGroupEquals(&quot;myJobGroup&quot;), jobGroupEquals(&quot;yourGroup&quot;))); 添加对所有job感兴趣的JobListener： 1scheduler.getListenerManager().addJobListener(myJobListener, allJobs()); Job StoresRAMJobStore 将所有数据保存在RAM中,速度快但易失 1org.quartz.jobStore.class = org.quartz.simpl.RAMJobStore JDBC JobStore 通过JDBC将其所有数据保存在数据库中 1org.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreTX quartz.properties12345678910111213141516171819202122232425262728293031323334# 调度标识名 集群中每一个实例都必须使用相同的名称 （区分特定的调度器实例）org.quartz.scheduler.instanceName=DefaultQuartzScheduler# ID设置为自动获取 每一个必须不同 （所有调度器实例中是唯一的）org.quartz.scheduler.instanceId=AUTO# 使用内存存储quartz的所有数据，包括job和trigger的配置#org.quartz.jobStore.class = org.quartz.simpl.RAMJobStore# 数据保存方式为持久化org.quartz.jobStore.class=org.quartz.impl.jdbcjobstore.JobStoreTX# 表的前缀org.quartz.jobStore.tablePrefix=QRTZ_# 设置为TRUE不会出现序列化非字符串类到 BLOB 时产生的类版本问题# org.quartz.jobStore.useProperties = true# 加入集群 true 为集群 false不是集群org.quartz.jobStore.isClustered=false# 调度实例失效的检查时间间隔org.quartz.jobStore.clusterCheckinInterval=20000# 容许的最大作业延长时间org.quartz.jobStore.misfireThreshold=60000# ThreadPool 实现的类名org.quartz.threadPool.class=org.quartz.simpl.SimpleThreadPool# 线程池中有10个线程，这意味着最多可以同时运行10个joborg.quartz.threadPool.threadCount=10# 线程优先级org.quartz.threadPool.threadPriority=5（threadPriority 属性的最大值是常量 java.lang.Thread.MAX_PRIORITY，等于10。最小值为常量 java.lang.Thread.MIN_PRIORITY，为1）# 自创建父线程# org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread = true# 数据库别名org.quartz.jobStore.dataSource=qzDS# 设置数据源org.quartz.dataSource.qzDS.driver=com.mysql.jdbc.Driverorg.quartz.dataSource.qzDS.URL=jdbc:mysql://localhost:3306/quartzorg.quartz.dataSource.qzDS.user=rootorg.quartz.dataSource.qzDS.password=123456org.quartz.dataSource.qzDS.maxConnection=10 简单实例依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt;&lt;/dependency&gt; job 12345678public class PrintJob extends QuartzJobBean &#123; @Override protected void executeInternal(final JobExecutionContext context) throws JobExecutionException &#123; System.out.println(&quot;当前时间: &quot; + new Date()); &#125;&#125; Scheduler 12345678910111213141516171819202122232425262728public class MyScheduler &#123; public static void main(String[] args) throws SchedulerException, InterruptedException &#123; // 1、创建调度器Scheduler SchedulerFactory schedulerFactory = new StdSchedulerFactory(); Scheduler scheduler = schedulerFactory.getScheduler(); // 2、创建JobDetail实例，并与PrintWordsJob类绑定(Job执行内容) JobDetail jobDetail = JobBuilder.newJob(PrintJob.class) .withIdentity(&quot;job1&quot;, &quot;group1&quot;).build(); // 3、构建Trigger实例,每隔1s执行一次 Trigger trigger = TriggerBuilder.newTrigger().withIdentity(&quot;trigger1&quot;, &quot;triggerGroup1&quot;) .startNow()//立即生效 .withSchedule(SimpleScheduleBuilder.simpleSchedule() .withIntervalInSeconds(1)//每隔1s执行一次 .repeatForever()).build();//一直执行 //4、绑定schedule和jobDetail scheduler.scheduleJob(jobDetail, trigger); System.out.println(&quot;--------scheduler start ! ------------&quot;); //5、执行 scheduler.start(); //睡眠 TimeUnit.MINUTES.sleep(1); scheduler.shutdown(); System.out.println(&quot;--------scheduler shutdown ! ------------&quot;); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://wajj.xin/categories/java/"},{"name":"Quartz","slug":"java/Quartz","permalink":"http://wajj.xin/categories/java/Quartz/"}],"tags":[{"name":"java","slug":"java","permalink":"http://wajj.xin/tags/java/"},{"name":"Quartz","slug":"Quartz","permalink":"http://wajj.xin/tags/Quartz/"}]},{"title":"nginx","slug":"Linux/nginx/nginx","date":"2021-04-16T13:21:10.000Z","updated":"2021-04-19T07:20:11.014Z","comments":true,"path":"2021/04/16/Linux/nginx/nginx/","link":"","permalink":"http://wajj.xin/2021/04/16/Linux/nginx/nginx/","excerpt":"","text":"nginx高性能的HTTP和反向代理服务器,也提供IMAP/POP3/SMTP服务 特点: ​ 内存占用少 ​ 并发强(5w) ​ 能够热部署 配置文件nginx配置文件中分为三部分:全局块,events块,http块 nginx.conf 结构图可以这样概括： 12345678910main # 全局配置，对全局生效├── events # 配置影响 Nginx 服务器或与用户的网络连接├── http # 配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置│ ├── upstream # 配置后端服务器具体地址，负载均衡配置不可或缺的部分│ ├── server # 配置虚拟主机的相关参数，一个 http 块中可以有多个 server 块│ ├── server│ │ ├── location # server 块可以包含多个 location 块，location 指令用于匹配 uri│ │ ├── location│ │ └── ...│ └── ... 语法 配置文件由指令与指令块构成； 每条指令以 ; 分号结尾，指令与参数间以空格符号分隔； 指令块以 &#123;&#125; 大括号将多条指令组织在一起； include 语句允许组合多个配置文件以提升可维护性； 使用 # 符号添加注释，提高可读性； 使用 $ 符号使用变量； 部分指令的参数支持正则表达式； server 块可以包含多个 location 块，location 指令用于匹配 uri，语法： 123location [ &#x3D; | ~ | ~* | ^~] uri &#123; ...&#125; 指令后面： = 精确匹配路径，用于不含正则表达式的 uri 前，如果匹配成功，不再进行后续的查找； ^~ 用于不含正则表达式的 uri； 前，表示如果该符号后面的字符是最佳匹配，采用该规则，不再进行后续的查找； ~ 表示用该符号后面的正则去匹配路径，区分大小写； ~* 表示用该符号后面的正则去匹配路径，不区分大小写。跟 ~ 优先级都比较低，如有多个location的正则能匹配的话，则使用正则表达式最长的那个； 如果 uri 包含正则表达式，则必须要有 ~ 或 ~* 标志。 正反向代理正向代理: 代理客户端,请求通过代理服务器进行互联网访问,隐藏了真实的客户端地址，代理服务器为客户端收发请求，使真实客户端对服务器不可见 代理服务器端,客户端不需要任何配置,将请求发送给反向代理服务器,反向代理服务器会对请求进行分发,在客户端视角不知道有分发的过程,认为反向代理服务器和目标服务器是一个整体 服务器只暴露了反向代理服务器地址,隐藏了真实服务器地址,提高了安全性 配置: 负载均衡 Nginx提供的负载均衡策略有2种：内置策略和扩展策略。 内置策略为轮询，加权轮询，Ip hash。 轮询，默认方式，每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务挂了，能自动剔除； weight，权重分配，指定轮询几率，权重越高，在被访问的概率越大，用于后端服务器性能不均的情况； ip_hash，每个请求按访问 IP 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决动态网页 session 共享问题。负载均衡每次请求都会重新定位到服务器集群中的某一个，那么已经登录某一个服务器的用户再重新定位到另一个服务器，其登录信息将会丢失，这样显然是不妥的； fair（第三方），按后端服务器的响应时间分配，响应时间短的优先分配，依赖第三方插件 nginx-upstream-fair，需要先安装； 动静分离在我们的开发中，有些请求是需要后台处理的，有些请求是不需要经过后台处理的（如：css、html、jpg、js等等文件），这些不需要经过后台处理的文件称为静态文件。 让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作。提高资源响应的速度。 方式 纯粹把静态文件独立成单独的域名，放在独立的服务器上(主流) 动态跟静态文件混合在一起发布， 通过 Nginx 配置来分开 建议搭配缓存使用 通过 expires 参数设置，可以使浏览器缓存过期时间，减少与服务器之前的请求和流量。 具体 expires 定义：是给一个资源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，所以不会产生额外的流量。此种方法非常适合不经常变动的资源。 设置为3d，表示在这 3 天之内访问这个URL，发送一个请求，比对服务器该文件最后更新时间没有变化。则不会从服务器抓取，返回状态码 304，如果有修改，则直接从服务器重新下载，返回状态码 200。 GZip使用 gzip 不仅需要 Nginx 配置，浏览器端也需要配合，需要在请求消息头中包含 Accept-Encoding: gzip（IE5 之后所有的浏览器都支持了，是现代浏览器的默认设置）。一般在请求 html 和 css 等静态资源的时候，支持的浏览器在 request 请求静态资源的时候，会加上 Accept-Encoding: gzip 这个 header，表示自己支持 gzip 的压缩方式，Nginx 在拿到这个请求的时候，如果有相应配置，就会返回经过 gzip 压缩过的文件给浏览器，并在 response 相应的时候加上 content-encoding: gzip 来告诉浏览器自己采用的压缩方式（因为浏览器在传给服务器的时候一般还告诉服务器自己支持好几种压缩方式），浏览器拿到压缩的文件后，根据自己的解压方式进行解析。 12345678910111213# &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;gzip.confgzip on; # 默认off，是否开启gzipgzip_types text&#x2F;plain text&#x2F;css application&#x2F;json application&#x2F;x-javascript text&#x2F;xml application&#x2F;xml application&#x2F;xml+rss text&#x2F;javascript;# 上面两个开启基本就能跑起了，下面的愿意折腾就了解一下gzip_static on;gzip_proxied any;gzip_vary on;gzip_comp_level 6;gzip_buffers 16 8k;# gzip_min_length 1k;gzip_http_version 1.1; 稍微解释一下： gzip_types：要采用 gzip 压缩的 MIME 文件类型，其中 text/html 被系统强制启用； gzip_static：默认 off，该模块启用后，Nginx 首先检查是否存在请求静态文件的 gz 结尾的文件，如果有则直接返回该 .gz 文件内容； gzip_proxied：默认 off，nginx做为反向代理时启用，用于设置启用或禁用从代理服务器上收到相应内容 gzip 压缩； gzip_vary：用于在响应消息头中添加 Vary：Accept-Encoding，使代理服务器根据请求头中的 Accept-Encoding 识别是否启用 gzip 压缩； gzip_comp_level：gzip 压缩比，压缩级别是 1-9，1 压缩级别最低，9 最高，级别越高压缩率越大，压缩时间越长，建议 4-6； gzip_buffers：获取多少内存用于缓存压缩结果，16 8k 表示以 8k*16 为单位获得； gzip_min_length：允许压缩的页面最小字节数，页面字节数从header头中的 Content-Length 中进行获取。默认值是 0，不管页面多大都压缩。建议设置成大于 1k 的字节数，小于 1k 可能会越压越大； gzip_http_version：默认 1.1，启用 gzip 所需的 HTTP 最低版本； 这个配置可以插入到 http 模块整个服务器的配置里，也可以插入到需要使用的虚拟主机的 server 或者下面的 location 模块中，当然像上面我们这样写的话就是被 include 到 http 模块中了。 安装1234#安装apt-get install nginx#启动service nginx start 目录 /usr/sbin/nginx：主程序 /etc/nginx：存放配置文件 /usr/share/nginx：存放静态文件 /var/log/nginx：存放日志 命令12345678# 查看nginx状态nginx -t# 重新载入配置文件nginx -s reload# 重启 Nginxnginx -s reopen# 停止 Nginxnginx -s stop","categories":[{"name":"Linux","slug":"Linux","permalink":"http://wajj.xin/categories/Linux/"},{"name":"nginx","slug":"Linux/nginx","permalink":"http://wajj.xin/categories/Linux/nginx/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://wajj.xin/tags/Linux/"},{"name":"nginx","slug":"nginx","permalink":"http://wajj.xin/tags/nginx/"}]},{"title":"mysql","slug":"数据库/mysql/mysql","date":"2021-04-11T12:51:41.000Z","updated":"2021-04-19T07:20:11.024Z","comments":true,"path":"2021/04/11/数据库/mysql/mysql/","link":"","permalink":"http://wajj.xin/2021/04/11/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql/","excerpt":"","text":"mysql连接数据库1234567891011# mysql 5 驱动 com.mysql.jdbc.Driverspring.datasource.username=rootspring.datasource.password=rootspring.datasource.url=jdbc:mysql://localhost:3306/test?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8spring.datasource.driver-classs-name=com.mysql.jdbc.Driver# mysql 8 驱动 com.mysql.cj.jdbc.Driver 需要增加时区配置spring.datasource.username=rootspring.datasource.password=rootspring.datasource.url=jdbc:mysql://localhost:3306/test?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghaispring.datasource.driver-classs-name=com.mysql.cj.jdbc.Driver useSSL=false 是否使用安全连接 useUnicode=true&amp;charactgerEncoding=UTF-8 使用utf-8的格式存取数据 serverTimezone=Asia/Shanghai 时区设置,还可以为GMT%wb8(GMT+8)","categories":[{"name":"mysql","slug":"mysql","permalink":"http://wajj.xin/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://wajj.xin/tags/mysql/"}]},{"title":"mybatis-plus","slug":"java/mybatis/mybatis-plus","date":"2021-04-11T12:51:41.000Z","updated":"2021-04-19T07:20:11.020Z","comments":true,"path":"2021/04/11/java/mybatis/mybatis-plus/","link":"","permalink":"http://wajj.xin/2021/04/11/java/mybatis/mybatis-plus/","excerpt":"","text":"mybatis-plus简化mybatis开发,对mybatis进行增强,不进行改变 特性 无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑 损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作 强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求 支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错 支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题 支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作 支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ） 内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用 内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询 分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库 内置性能分析插件：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询 内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作 依赖123456789101112131415&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 不要同时导入mybatis和mybatis-plus 使用 编写Dao,继承BaseMapper 继承了 BaseMapper 就完成了基本的crud 添加 @Mapper 或者 @Repository 表示为 Dao 层 添加启动类扫描 Mapper 包下的所有接口 @MapperScan(“com.wxy.dao”) 配置日志控制台打印: 123mybatis-plus: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl 方法查询单个查询 selectById() selectOne() 查询多个 selectBatchIds(Arrays.asList(1,2,3)) selectList() 条件查询 selectByMap() 通过map自定义查询条件 分页查询 编写分页插件配置 12345678910111213141516171819202122232425package com.wxy.config.mybatisPlus;import org.mybatis.spring.annotation.MapperScan;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.transaction.annotation.EnableTransactionManagement;import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;@EnableTransactionManagement@Configurationpublic class MyBatisPlusConfig &#123; @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() &#123; final MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor(); //分页配置 mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor()); return mybatisPlusInterceptor; &#125;&#125; 使用 123456public void testpage()&#123; Page&lt;User&gt; page = new Page&lt;&gt;(1,5); userMapper.selectPage(page,null); page.getRecords().forEach(System.out::println);&#125; 删除 deleteById() deleteByMap() deleteBatchId(Arrays.asList(1,2,3)) 逻辑删除 添加 deleted 字段 实体类中添加注解 @TableLogic 逻辑删除注解 配置逻辑删除组件 123456mybatis-plus: global-config: db-config: logic-delete-field: deleted # 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2) logic-delete-value: 1 # 逻辑已删除值(默认为 1) logic-not-delete-value: 0 # 逻辑未删除值(默认为 0) 插入insert自动生成全局唯一id并回填 主键生成策略分布式系统唯一ID生成方案汇总 默认 ID_WORKER 全局唯一ID @TableId(type = IdType.ID_WORKER ) 雪花算法Twitter开源的分布式ID生成算法,结果是long型的. 使用41bit作为毫秒数,10bit作为机器ID(5bit数据中心,5bit机器ID),12bit作为毫秒内的流水号(每个节点每毫秒可以产生4096个ID),1bit符号为(永远为0) 主键自增 @TableId(type = IdType.AUTO) 实体类上添加 @TableId(type = IdType.AUTO) 注解 数据库字段是自增的 值 描述 AUTO 数据库自增(mysql) NONE 无主键ID INPUT 自定义输入 ASSIGN_ID 雪花算法,主键可以是Long,Integer,String类型 ASSIGN_UUID 不含中划线的UUID,主键是String类型 更新updateById() 通过条件自动动态配置sql,参数是对应的对象 自动填充 数据库 在表中新增字段 create_time update_time ,设置默认值(CURRENT_TIMESTAMP) 代码 实体类的字段上添加注解 @TableField(fill = FieldFill.INSERT) //在新增时进行填充 @TableField(fill = FieldFill.INSERT_UPDATE) //在新增和修改时进行填充 … 编写处理器处理注解 1234567891011121314151617181920212223import java.util.Date;import org.apache.ibatis.reflection.MetaObject;import org.springframework.stereotype.Component;import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;@Componentpublic class MyMetaObjectHandler implements MetaObjectHandler &#123; @Override public void insertFill(final MetaObject metaObject) &#123; this.setFieldValByName(&quot;createTime&quot;, new Date(), metaObject); this.setFieldValByName(&quot;updateTime&quot;, new Date(), metaObject); &#125; @Override public void updateFill(final MetaObject metaObject) &#123; this.setFieldValByName(&quot;updateTime&quot;, new Date(), metaObject); &#125;&#125; 乐观锁乐观锁 : 认为不会出现问题,无论干什么都不会加锁.如果出问题,再次更新 悲观锁 : 认为总是会出现问题,无论干什么都会去加锁,然后去操作 乐观锁实现方式： 取出记录时，获取当前 version 更新时，带上这个version 执行更新时， set version = newVersion where version = oldVersion 如果version不对，就更新失败 MP操作 添加 version 字段,默认值为 1 实体类添加对应字段,添加 @Version 乐观锁注解 注册组件 123456789101112131415161718192021222324package com.wxy.config.mybatisPlus;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.transaction.annotation.EnableTransactionManagement;import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;@EnableTransactionManagement@Configurationpublic class MyBatisPlusConfig &#123; @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() &#123; final MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor(); //乐观锁 mybatisPlusInterceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor()); return mybatisPlusInterceptor; &#125;&#125; 测试 1234567891011// 测试乐观锁成功！@Test public void testOptimisticLocker()&#123; // 1、查询用户信息 User user = userMapper.selectById(1L); // 2、修改用户信息 user.setName(&quot;kuangshen&quot;); user.setEmail(&quot;24736743@qq.com&quot;); // 3、执行更新操作 userMapper.updateById(user); &#125; 12345678910111213141516171819// 测试乐观锁失败！多线程下 @Test public void testOptimisticLocker2()&#123; // 线程 1 User user = userMapper.selectById(1L); user.setName(&quot;kuangshen111&quot;); user.setEmail(&quot;24736743@qq.com&quot;); // 模拟另外一个线程执行了插队操作 User user2 = userMapper.selectById(1L); user2.setName(&quot;kuangshen222&quot;); user2.setEmail(&quot;24736743@qq.com&quot;); userMapper.updateById(user2); // 自旋锁来多次尝试提交！ userMapper.updateById(user); // 如果没有乐观锁就会覆盖插队线程的值！&#125; 条件构造器Wrapper QueryWrapper LambdaQueryWrapper UpdateWrapper LambdaUpdateWrapper 方法 说明 ge 大于等于 gt 大于 le 小于等于 lt 小于 isNull 空 isNotNull 不为空 方法 说明 allEq 全eq eq 等于 = ne 不等于 &lt;&gt; 方法 说明 例子 between BETWEEN 值1 AND 值2 between(“age”, 18, 30) notBetween NOT BETWEEN 值1 AND 值2 方法 说明 like LIKE ‘%值%’ notlike NOT LIKE ‘%值%’ likeLeft LIKE ‘%值’ likeRight LIKE ‘值%’ 性能分析插件 添加插件 123456789/** * SQL执行效率插件 */@Bean @Profile(&#123;&quot;dev&quot;,&quot;test&quot;&#125;)// 设置 dev test 环境开启，保证我们的效率 public PerformanceInterceptor performanceInterceptor() &#123; PerformanceInterceptor performanceInterceptor = new PerformanceInterceptor(); performanceInterceptor.setMaxTime(100); // ms设置sql执行的最大时间，如果超过了则不 执行 performanceInterceptor.setFormat(true); // 是否格式化代码 return performanceInterceptor;&#125; 执行sql,执行时间超过限定会抛出异常 新版已更换为 p6spy 代码自动生成依赖 123456789101112131415161718192021222324&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt; &lt;version&gt;2.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-extension&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt;&lt;/dependency&gt; 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import java.util.ArrayList;import com.baomidou.mybatisplus.annotation.DbType;import com.baomidou.mybatisplus.annotation.FieldFill;import com.baomidou.mybatisplus.annotation.IdType;import com.baomidou.mybatisplus.generator.AutoGenerator;import com.baomidou.mybatisplus.generator.config.DataSourceConfig;import com.baomidou.mybatisplus.generator.config.GlobalConfig;import com.baomidou.mybatisplus.generator.config.PackageConfig;import com.baomidou.mybatisplus.generator.config.StrategyConfig;import com.baomidou.mybatisplus.generator.config.po.TableFill;import com.baomidou.mybatisplus.generator.config.rules.DateType;import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;// 代码自动生成器public class CodeGenerator &#123; public static void main(final String[] args) &#123; // 需要构建一个 代码自动生成器 对象 final AutoGenerator mpg = new AutoGenerator(); // 配置策略 // 1、全局配置 final GlobalConfig gc = new GlobalConfig(); final String projectPath = System.getProperty(&quot;user.dir&quot;); gc.setOutputDir(projectPath + &quot;/demo/src/main/java&quot;); gc.setAuthor(&quot;abc&quot;); // 是否打开输出目录 gc.setOpen(false); // 是否覆盖 gc.setFileOverride(true); // 去Service的I前缀 gc.setServiceName(&quot;%sService&quot;); gc.setMapperName(&quot;%sDao&quot;); gc.setIdType(IdType.AUTO); gc.setDateType(DateType.ONLY_DATE); gc.setSwagger2(true); mpg.setGlobalConfig(gc); //2、设置数据源 final DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl( &quot;jdbc:mysql://localhost:3306/abbbb? useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8&quot;); dsc.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;); dsc.setUsername(&quot;root&quot;); dsc.setPassword(&quot;123&quot;); dsc.setDbType(DbType.MYSQL); mpg.setDataSource(dsc); //3、包的配置 final PackageConfig pc = new PackageConfig(); //只需要改实体类名字 和包名 还有 数据库配置即可 pc.setModuleName(&quot;cat&quot;); pc.setParent(&quot;com.abc&quot;); pc.setEntity(&quot;model.entity&quot;); pc.setMapper(&quot;dao&quot;); pc.setService(&quot;service&quot;); pc.setController(&quot;controller&quot;); mpg.setPackageInfo(pc); //4、策略配置 final StrategyConfig strategy = new StrategyConfig(); strategy.setInclude(&quot;表名1&quot;,&quot;表名2&quot;); // 设置要映射的表名驼峰命名 strategy.setNaming(NamingStrategy.underline_to_camel); strategy.setColumnNaming(NamingStrategy.underline_to_camel); // 自动lombok； strategy.setEntityLombokModel(true); // 配置逻辑删除 strategy.setLogicDeleteFieldName(&quot;deleted&quot;); // 自动填充配置 final TableFill gmtCreate = new TableFill(&quot;create_time&quot;, FieldFill.INSERT); final TableFill gmtModified = new TableFill(&quot;update_time&quot;, FieldFill.INSERT_UPDATE); final ArrayList&lt;TableFill&gt; tableFills = new ArrayList&lt;&gt;(); tableFills.add(gmtCreate); tableFills.add(gmtModified); strategy.setTableFillList(tableFills); // 乐观锁 strategy.setVersionFieldName(&quot;version&quot;); strategy.setRestControllerStyle(true); // 驼峰转连字符 abc/hello_id // strategy.setControllerMappingHyphenStyle(true); mpg.setStrategy(strategy); mpg.execute(); //执行 &#125;&#125; mybatis-generator依赖 12345678910111213141516171819202122232425&lt;build&gt; &lt;plugins&gt; &lt;!--mybatis generator--&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt; &lt;configuration&gt; &lt;!-- 在控制台打印执行日志 --&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;!-- 重复生成时会覆盖之前的文件--&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;configurationFile&gt;src/main/resources/generatorConfig.xml&lt;/configurationFile&gt; &lt;/configuration&gt; &lt;!-- 数据库连接选择8.0以上的，因为用的mysql8.0--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;!-- targetRuntime：设置生成的文件适用于那个 mybatis 版本 --&gt; &lt;context id=&quot;default&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;!--optional,指在创建class时，对注释进行控制--&gt; &lt;commentGenerator&gt; &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt; &lt;/commentGenerator&gt; &lt;!--jdbc的数据库连接 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/abc?useUnicode=true&amp;amp;characeterEncoding=utf-8&amp;amp;serverTimezone=UTC&quot; userId=&quot;root&quot; password=&quot;root&quot;&gt; &lt;/jdbcConnection&gt; &lt;!--非必须，类型处理器，在数据库类型和java类型之间的转换控制--&gt; &lt;javaTypeResolver&gt; &lt;!-- 默认情况下数据库中的 decimal，bigInt 在 Java 对应是 sql 下的 BigDecimal 类 --&gt; &lt;!-- 不是 double 和 long 类型 --&gt; &lt;!-- 使用常用的基本类型代替 sql 包下的引用类型 --&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt; &lt;/javaTypeResolver&gt; &lt;!-- targetPackage：生成的实体类所在的包 --&gt; &lt;!-- targetProject：生成的实体类所在的硬盘位置 --&gt; &lt;javaModelGenerator targetPackage=&quot;com.abc.model.entity&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;!-- 是否允许子包 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt; &lt;!-- 是否清理从数据库中查询出的字符串左右两边的空白字符 --&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt; &lt;/javaModelGenerator&gt; &lt;!-- targetPackage 和 targetProject：生成的 mapper 文件的包和位置 --&gt; &lt;sqlMapGenerator targetPackage=&quot;/mapper/abc&quot; targetProject=&quot;src/main/resources&quot;&gt; &lt;!-- 针对数据库的一个配置，是否把 schema 作为字包名 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- targetPackage 和 targetProject：生成的 interface 文件的包和位置 --&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.abc.dao&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;!-- 针对 oracle 数据库的一个配置，是否把 schema 作为字包名 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt; &lt;/javaClientGenerator&gt; &lt;!-- &lt;table tableName=&quot;%&quot; schema=&quot;abc&quot;--&gt; &lt;!-- enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot;--&gt; &lt;!-- enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot;--&gt; &lt;!-- selectByExampleQueryId=&quot;false&quot;/&gt;--&gt; &lt;!-- tableName是数据库中的表名，domainObjectName是生成的JAVA模型名，后面的参数不用改，要生成更多的表就在下面继续加table标签 --&gt; &lt;table tableName=&quot;abc&quot; domainObjectName=&quot;abc&quot; enableInsert=&quot;true&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt; &lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt;","categories":[{"name":"java","slug":"java","permalink":"http://wajj.xin/categories/java/"},{"name":"mybatis","slug":"java/mybatis","permalink":"http://wajj.xin/categories/java/mybatis/"}],"tags":[{"name":"java","slug":"java","permalink":"http://wajj.xin/tags/java/"},{"name":"mybatis","slug":"mybatis","permalink":"http://wajj.xin/tags/mybatis/"}]},{"title":"Spring Security","slug":"java/SpringSecurity/SpringSecurity","date":"2021-04-11T12:51:41.000Z","updated":"2021-04-27T13:26:40.186Z","comments":true,"path":"2021/04/11/java/SpringSecurity/SpringSecurity/","link":"","permalink":"http://wajj.xin/2021/04/11/java/SpringSecurity/SpringSecurity/","excerpt":"","text":"Spring Securityhttps://github.com/lenve/spring-security-samples 依赖使用springboot进行版本管理 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 主要是其中的两个 添加完依赖就可以使用了,默认开启保护所有接口 默认实现会生成一个登陆页面,账号为user,密码是在控制台打印的一串UUID 和用户相关的自动化配置类在 UserDetailsServiceAutoConfiguration 里边，在该类的 getOrDeducePassword 方法中，我们看到如下一行日志： 123if (user.isPasswordGenerated()) &#123; logger.info(String.format(&quot;%n%nUsing generated security password: %s%n&quot;, user.getPassword()));&#125; 通过getPassword()可以查看具体用户名和密码 SecurityProperties中用户名是user,密码是UUID 默认isPasswordGenerated()是true 修改用户名 默认用户定义在SecurityProperties类的User静态内部类中,配置注解有spring.security前缀 1234@ConfigurationProperties(prefix = &quot;spring.security&quot;)publicclass SecurityProperties &#123; ...&#125; 所以在application.properties中添加 12spring.security.user.name=javaboyspring.security.user.password=123 在application.properties中定义的用户名密码最终是通过 set 方法注入到属性中去的，查看SecurityProperties.User#setPassword 方法 1234567public void setPassword(String password) &#123; if (!StringUtils.hasLength(password)) &#123; return; &#125; this.passwordGenerated = false; this.password = password;&#125; 从这里我们可以看到，application.properties 中定义的密码在注入进来之后，还顺便设置了 passwordGenerated 属性为 false，这个属性设置为 false 之后，控制台就不会打印默认的密码了。 内存存储的用户方式1 123456789101112@Configurationpublicclass SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.inMemoryAuthentication() .withUser(&quot;user&quot;) .password(&quot;123&quot;).roles(&quot;user&quot;) .and() .withUser(&quot;admin&quot;) .password(&quot;admin&quot;).roles(&quot;USER&quot;,&quot;ADMIN&quot;); &#125;&#125; 首先我们自定义 SecurityConfig 继承自 WebSecurityConfigurerAdapter，重写 configure 方法。 configure 方法中，我们通过 inMemoryAuthentication 来开启在内存中定义用户，withUser 中是用户名，password 中则是用户密码，roles 中是用户角色。 配置多个用户，用 and 相连 方式2由于 Spring Security 支持多种数据源，例如内存、数据库、LDAP 等，这些不同来源的数据被共同封装成了一个 UserDetailService 接口，任何实现了该接口的对象都可以作为认证数据源。可以通过重写 WebSecurityConfigurerAdapter 中的 userDetailsService 方法来提供一个 UserDetailService 实例进而配置多个用户： 1234567@Beanprotected UserDetailsService userDetailsService() &#123; InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager(); manager.createUser(User.withUsername(&quot;javaboy&quot;).password(&quot;123&quot;).roles(&quot;admin&quot;).build()); manager.createUser(User.withUsername(&quot;江南一点雨&quot;).password(&quot;123&quot;).roles(&quot;user&quot;).build()); return manager;&#125; BCryptPasswordEncoder加密官方推荐使用BCryptPasswordEncoder,使用 BCrypt 强哈希函数 使用时可以选择提供 strength 和 SecureRandom 实例。 strength 越大，密钥的迭代次数越多，密钥迭代次数为 2^strength。strength 取值在 4~31 之间，默认为 10。 SecureRandom 生成加密强随机数 自带盐值 PasswordEncoder1234567publicinterface PasswordEncoder &#123; String encode(CharSequence rawPassword); boolean matches(CharSequence rawPassword, String encodedPassword); default boolean upgradeEncoding(String encodedPassword) &#123; returnfalse; &#125;&#125; encode 方法用来对明文密码进行加密，返回加密之后的密文。 matches 方法是一个密码校对方法，用户传的明文密码和数据库中保存的密文密码作为参数，传到方法中，根据返回的 Boolean 值判断是否输入正确。 upgradeEncoding 是否还要进行再次加密，这个一般来说就不用了。 使用在SecurityConfig 中 添加 PasswordEncoder 的实例 12345678@Configurationpublicclass SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Bean PasswordEncoder passwordEncoder() &#123; // return NoOpPasswordEncoder.getInstance(); //不对密码进行加密 return new BCryptPasswordEncoder(12); &#125;&#125; Spring Security 5.0 开始需要选择密码加密方式,不然会报错 配置登录页面SecurityConfig 类中重写 configure(WebSecurity web) 和 configure(HttpSecurity http) 12345678910111213141516171819@Configurationpublicclass SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override public void configure(WebSecurity web) throws Exception &#123; web.ignoring().antMatchers(&quot;/js/**&quot;, &quot;/css/**&quot;,&quot;/images/**&quot;); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .anyRequest().authenticated() .and() .formLogin() .loginPage(&quot;/login.html&quot;) .loginProcessingUrl(&quot;/login&quot;) .permitAll() .and() .csrf().disable(); &#125;&#125; web.ignoring() 用来配置忽略掉的 URL 地址，一般对于静态文件，我们可以采用此操作。 如果我们使用 XML 来配置 Spring Security ，里边会有一个重要的标签 &lt;http&gt;，HttpSecurity 提供的配置方法 都对应了该标签。 authorizeRequests 对应了 &lt;intercept-url&gt;,用于拦截url formLogin 对应了 &lt;formlogin&gt;。 loginProcessingUrl 配置了登录的请求路径 and 方法表示结束当前标签，上下文回到HttpSecurity，开启新一轮的配置。 permitAll 表示不拦截配置的接口。 关闭 csrf 配置页面 当我们定义了登录页面为 /login.html 的时,没有配置 loginProcessingUrl，Spring Security 也会帮我们自动注册一个 /login.html 的接口，用来处理登录逻辑。 FormLoginConfigurer 类 123456protected final void updateAuthenticationDefaults() &#123; if (loginProcessingUrl == null) &#123; loginProcessingUrl(loginPage); &#125; // ...&#125; 登录表单中输入框的参数默认是 username 和 password FormLoginConfigurer 类构造方法中，配置了指定变量值 12345public FormLoginConfigurer() &#123; super(new UsernamePasswordAuthenticationFilter(), null); usernameParameter(&quot;username&quot;); passwordParameter(&quot;password&quot;);&#125; 指定参数 12345678.and().formLogin().loginPage(&quot;/login.html&quot;).loginProcessingUrl(&quot;/login&quot;).usernameParameter(&quot;name&quot;).passwordParameter(&quot;passwd&quot;).permitAll().and() 注意修改前端页面 input 的 name 属性值和服务端的对应。 登录回调分为 前后端分离登录 和 前后端不分登录 前后端分离登录在前后端分离这样的开发架构下，前后端的交互都是通过 JSON 来进行，无论登录成功还是失败，都不会有什么服务端跳转或者客户端跳转之类。前端收到了登录结果,根据结果进行判断,然后跳转 登录数据保存状态无状态登录 session 是有状态服务，即服务端需要记录每次会话的客户端信息，从而识别客户端身份，根据用户身份进行请求的处理 例如登录：用户登录后，我们把用户的信息保存在服务端 session 中，并且给用户一个 cookie 值，记录对应的 session，然后下次请求，用户携带 cookie 值来（这一步有浏览器自动完成），我们就能识别到对应 session，从而找到用户的信息。 缺点: 服务端保存大量数据，增加服务端压力 服务端保存用户状态，不支持集群化部署 无状态登录 jwt 微服务集群中的每个服务，对外提供的都使用 RESTful 风格的接口。而 RESTful 风格的一个最重要的规范就是：服务的无状态性，即： 服务端不保存任何客户端请求者信息 客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份 好处 客户端请求不依赖服务端的信息，多次请求不需要必须访问到同一台服务器 服务端的集群和状态对客户端透明 服务端可以任意的迁移和伸缩（可以方便的进行集群化部署） 减小服务端存储压力 实现无状态登录 首先客户端发送账户名/密码到服务端进行认证 认证通过后，服务端将用户信息加密并且编码成一个 token，返回给客户端 以后客户端每次发送请求，都需要携带认证的 token 服务端对客户端发送来的 token 进行解密，判断是否有效，并且获取用户登录信息 登录成功使用successHandler 12345678.successHandler((req, resp, authentication) -&gt; &#123; Object principal = authentication.getPrincipal(); resp.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter out = resp.getWriter(); out.write(new ObjectMapper().writeValueAsString(principal)); out.flush(); out.close();&#125;) successHandler 方法的参数是一个 AuthenticationSuccessHandler 对象，这个对象中我们要实现的方法是 onAuthenticationSuccess。 onAuthenticationSuccess 方法有三个参数，分别是： HttpServletRequest HttpServletResponse Authentication 有了前两个参数，我们就可以在这里随心所欲的返回数据了。利用 HttpServletRequest 我们可以做服务端跳转，利用 HttpServletResponse 我们可以做客户端跳转，当然，也可以返回 JSON 数据。 第三个 Authentication 参数则保存了我们刚刚登录成功的用户信息。 登录失败失败的回调 AuthenticationFailureHandler 也是三个参数，前两个就不用说了，第三个是一个 Exception，对于登录失败，会有不同的原因，Exception 中则保存了登录失败的原因，我们可以将之通过 JSON 返回到前端。 12345678910111213141516171819.failureHandler((req, resp, e) -&gt; &#123; resp.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter out = resp.getWriter(); RespBean respBean = RespBean.error(e.getMessage()); if (e instanceof LockedException) &#123; respBean.setMsg(&quot;账户被锁定，请联系管理员!&quot;); &#125; elseif (e instanceof CredentialsExpiredException) &#123; respBean.setMsg(&quot;密码过期，请联系管理员!&quot;); &#125; elseif (e instanceof AccountExpiredException) &#123; respBean.setMsg(&quot;账户过期，请联系管理员!&quot;); &#125; elseif (e instanceof DisabledException) &#123; respBean.setMsg(&quot;账户被禁用，请联系管理员!&quot;); &#125; elseif (e instanceof BadCredentialsException) &#123; respBean.setMsg(&quot;用户名或者密码输入错误，请重新输入!&quot;); &#125; out.write(new ObjectMapper().writeValueAsString(respBean)); out.flush(); out.close();&#125;) 在 Spring Security 中，用户名查找失败对应的异常是： UsernameNotFoundException 密码匹配失败对应的异常是： BadCredentialsException 但是我们在登录失败的回调中，却总是看不到 UsernameNotFoundException 异常，无论用户名还是密码输入错误，抛出的异常都是 BadCredentialsException。 未认证处理方案在前后端分离中，如果用户没有登录就访问一个需要认证后才能访问的页面，这个时候，我们不应该让用户重定向到登录页面，而是给用户一个尚未登录的提示，前端收到提示之后，再自行决定页面跳转。 要解决这个问题，就涉及到 Spring Security 中的一个接口 AuthenticationEntryPoint ，该接口有一个实现类：LoginUrlAuthenticationEntryPoint ，该类中有一个方法 commence 这个方法是用来决定到底是要重定向还是要 forward，默认情况下请求使用重定向 重写这个方法，在方法中返回 JSON 即可，不再做重定向操作 123456789.csrf().disable().exceptionHandling().authenticationEntryPoint((req, resp, authException) -&gt; &#123; resp.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter out = resp.getWriter(); out.write(&quot;尚未登录，请先登录&quot;); out.flush(); out.close(); &#125;); 在 Spring Security 的配置中加上自定义的 AuthenticationEntryPoint 处理方法，该方法中直接返回相应的 JSON 提示即可。这样，如果用户再去直接访问一个需要认证之后才可以访问的请求，就不会发生重定向操作了，服务端会直接给浏览器一个 JSON 提示，浏览器收到 JSON 之后，该干嘛干嘛。 注销登录前后端分离项目，注销登录成功后返回 JSON 即可 123456789101112.and().logout().logoutUrl(&quot;/logout&quot;).logoutSuccessHandler((req, resp, authentication) -&gt; &#123; resp.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter out = resp.getWriter(); out.write(&quot;注销成功&quot;); out.flush(); out.close();&#125;).permitAll().and() 前后端不分离登录登录成功回调登录成功重定向 URL 相关的方法有两个,配置时只需要配置一个即可 defaultSuccessUrl defaultSuccessUrl 有一个重载的方法，我们先说一个参数的 defaultSuccessUrl 方法。如果我们在 defaultSuccessUrl 中指定登录成功的跳转页面为 /index，此时分两种情况，如果你是直接在浏览器中输入的登录地址，登录成功后，就直接跳转到 /index，如果你是在浏览器中输入了其他地址，例如 http://localhost:8080/hello，结果因为没有登录，又重定向到登录页面，此时登录成功后，就不会来到 /index ，而是来到 /hello 页面。 defaultSuccessUrl 还有一个重载的方法，第二个参数如果不设置默认为 false，也就是我们上面的的情况，如果手动设置第二个参数为 true，则 defaultSuccessUrl 的效果和 successForwardUrl 一致。 successForwardUrl successForwardUrl 表示不管你是从哪里来的，登录后一律跳转到 successForwardUrl 指定的地址。例如 successForwardUrl 指定的地址为 /index ，你在浏览器地址栏输入 http://localhost:8080/hello，结果因为没有登录，重定向到登录页面，当你登录成功之后，就会服务端跳转到 /index 页面；或者你直接就在浏览器输入了登录页面地址，登录成功后也是来到 /index。 12345678910.and().formLogin().loginPage(&quot;/login.html&quot;).loginProcessingUrl(&quot;/doLogin&quot;).usernameParameter(&quot;name&quot;).passwordParameter(&quot;passwd&quot;).defaultSuccessUrl(&quot;/index&quot;) // 只需要配置一个// .successForwardUrl(&quot;/index&quot;) // 只需要配置一个.permitAll().and() 登录失败回调与登录成功相似，登录失败也是有两个方法,配置时只需要配置一个即可 failureUrl : 在登录失败之后，会发生重定向。 failureForwardUrl : 登录失败之后会发生服务端跳转 注销登录注销登录的默认接口是 /logout，我们也可以配置。 12345678910.and().logout().logoutUrl(&quot;/logout&quot;) // 配置一个.logoutRequestMatcher(new AntPathRequestMatcher(&quot;/logout&quot;,&quot;POST&quot;)) // 配置一个.logoutSuccessUrl(&quot;/index&quot;).deleteCookies() //清除 cookie.clearAuthentication(true) //清除认证信息.invalidateHttpSession(true) //使 HttpSession 失效.permitAll().and() 默认注销的 URL 是 /logout，是一个 GET 请求，我们可以通过 logoutUrl 方法来修改默认的注销 URL。 logoutRequestMatcher 方法不仅可以修改注销 URL，还可以修改请求方式，实际项目中，这个方法和 logoutUrl 任意设置一个即可。 logoutSuccessUrl 表示注销成功后要跳转的页面。 deleteCookies 用来清除 cookie。 clearAuthentication 和 invalidateHttpSession 分别表示清除认证信息和使 HttpSession 失效，默认可以不用配置，默认就会清除。 配置权限在 Spring Security 的 configure(HttpSecurity http) 方法中配置拦截规则 1234567http.authorizeRequests() .antMatchers(&quot;&#x2F;admin&#x2F;**&quot;).hasRole(&quot;admin&quot;) .antMatchers(&quot;&#x2F;user&#x2F;**&quot;).hasRole(&quot;user&quot;) .anyRequest().authenticated() .and() ... ... 如果请求路径满足 /admin/** 格式，则用户需要具备 admin 角色。 如果请求路径满足 /user/** 格式，则用户需要具备 user 角色。 剩余的其他格式的请求路径，只需要认证（登录）后就可以访问。 使用了 Ant 风格的路径匹配符 通配符 含义 ** 匹配多层路径 * 匹配一层路径 ? 匹配任意单个字符 代码中配置的三条规则的顺序非常重要，Spring Security 在匹配的时候是按照从上往下的顺序来匹配，一旦匹配到了就不继续匹配了，「所以拦截规则的顺序不能写错」。 角色继承SecurityConfig 中添加角色继承关系 123456@BeanRoleHierarchy roleHierarchy() &#123; RoleHierarchyImpl hierarchy = new RoleHierarchyImpl(); hierarchy.setHierarchy(&quot;ROLE_admin &gt; ROLE_user&quot;); return hierarchy;&#125; 在配置时，需要给角色手动加上 ROLE_ 前缀。上面的配置表示 ROLE_admin 自动具备 ROLE_user 的权限。 使用数据库中用户信息Spring Security 支持多种不同的数据源，这些不同的数据源最终都将被封装成 UserDetailsService 的实例 UserDetailsService 的实现类中，除了 InMemoryUserDetailsManager 之外，还有一个 JdbcUserDetailsManager，使用 JdbcUserDetailsManager 可以让我们通过 JDBC 的方式将数据库和 Spring Security 连接起来。 脚本 JdbcUserDetailsManager 自己提供了一个数据库模型，这个数据库模型保存在如下位置： 1org&#x2F;springframework&#x2F;security&#x2F;core&#x2F;userdetails&#x2F;jdbc&#x2F;users.ddl 123create table users(username varchar_ignorecase(50) not null primary key,password varchar_ignorecase(500) not null,enabled boolean not null);create table authorities (username varchar_ignorecase(50) not null,authority varchar_ignorecase(50) not null,constraint fk_authorities_users foreign key(username) references users(username));create unique index ix_auth_username on authorities (username,authority); 脚本中有一种数据类型 varchar_ignorecase，这个其实是针对 HSQLDB 数据库创建的，MySQL 并不支持这种数据类型，所以需要手动调整数据类型，将 varchar_ignorecase 改为 varchar 。 执行完 SQL 脚本后，有两张表：users 和 authorities。 users 表中保存用户的基本信息，包括用户名、用户密码以及账户是否可用。 authorities 中保存了用户的角色。 authorities 和 users 通过 username 关联起来。 123456789101112131415@AutowiredDataSource dataSource;@Override@Beanprotected UserDetailsService userDetailsService() &#123; JdbcUserDetailsManager manager = new JdbcUserDetailsManager(); manager.setDataSource(dataSource); if (!manager.userExists(&quot;javaboy&quot;)) &#123; manager.createUser(User.withUsername(&quot;javaboy&quot;).password(&quot;123&quot;).roles(&quot;admin&quot;).build()); &#125; if (!manager.userExists(&quot;江南一点雨&quot;)) &#123; manager.createUser(User.withUsername(&quot;江南一点雨&quot;).password(&quot;123&quot;).roles(&quot;user&quot;).build()); &#125; return manager;&#125; 首先构建一个 JdbcUserDetailsManager 实例。 给 JdbcUserDetailsManager 实例添加一个 DataSource 对象。 调用 userExists 方法判断用户是否存在，如果不存在，就创建一个新的用户出来（因为每次项目启动时这段代码都会执行，所以加一个判断，避免重复创建用户）。 用户的创建方法和我们之前 InMemoryUserDetailsManager 中的创建方法基本一致。 这里的 createUser 或者 userExists 方法其实都是调用写好的 SQL 去判断的 如果在数据库中将用户的 enabled 属性设置为 false，表示禁用该账户，此时再使用该账户登录就会登录失败。 自定义定义用户实体类 实现 UserDetails12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Entity(name = &quot;t_user&quot;)public class User implements UserDetails &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String username; private String password; private boolean accountNonExpired; private boolean accountNonLocked; private boolean credentialsNonExpired; private boolean enabled; @ManyToMany(fetch = FetchType.EAGER,cascade = CascadeType.PERSIST) private List&lt;Role&gt; roles; @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; List&lt;SimpleGrantedAuthority&gt; authorities = new ArrayList&lt;&gt;(); for (Role role : getRoles()) &#123; authorities.add(new SimpleGrantedAuthority(role.getName())); &#125; return authorities; &#125; @Override public String getPassword() &#123; return password; &#125; @Override public String getUsername() &#123; return username; &#125; @Override public boolean isAccountNonExpired() &#123; return accountNonExpired; &#125; @Override public boolean isAccountNonLocked() &#123; return accountNonLocked; &#125; @Override public boolean isCredentialsNonExpired() &#123; return credentialsNonExpired; &#125; @Override public boolean isEnabled() &#123; return enabled; &#125; //省略其他 get/set 方法&#125; 定义 UserService 实现 UserDetailsService实现该接口，就要实现接口中的方法，也就是 loadUserByUsername ，这个方法的参数就是用户在登录的时候传入的用户名，根据用户名去查询用户信息（查出来之后，系统会自动进行密码比对）。 12345678910111213@Servicepublic class UserService implements UserDetailsService &#123; @Autowired UserDao userDao; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; User user = userDao.findUserByUsername(username); if (user == null) &#123; throw new UsernameNotFoundException(&quot;用户不存在&quot;); &#125; return user; &#125;&#125; 在 SecurityConfig 中配置用户123456@AutowiredUserService userService;@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(userService);&#125; 自动登录功能rememberMeSpring Security 中添加 .rememberMe() 123456789101112@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .anyRequest().authenticated() .and() .formLogin() .and() .rememberMe()// .key(&quot;javaboy&quot;) .and() .csrf().disable();&#125; 默认的登录页面多了一个选项，就是记住我。我们输入用户名密码，并且勾选上记住我这个框，然后点击登录按钮执行登录操作 登录数据中，除了 username 和 password 之外，还有一个 remember-me 登录成功之后，就会增加 cookie cookie是 Base64 加密的数据 1javaboy:1589104055373:2578ffbc26485c534a2ef929ac2efc47 第一段是用户名 第二段是一个两周后的时间戳 第三段是使用 MD5 散列函数算出来的值，他的明文格式是 username + &quot;:&quot; + tokenExpiryTime + &quot;:&quot; + password + &quot;:&quot; + key，最后的 key 是一个散列盐值，可以用来防治令牌被修改。 登录流程 在浏览器关闭后，并重新打开之后，用户再去访问 hello 接口，此时会携带着 cookie 中的 remember-me 到服务端，服务到拿到值之后，可以方便的计算出用户名和过期时间，再根据用户名查询到用户密码，然后通过 MD5 散列函数计算出散列值，再将计算出的散列值和浏览器传递来的散列值进行对比，就能确认这个令牌是否有效。 源码位置 令牌生成的过程 TokenBasedRememberMeServices#onLoginSuccess 首先从登录成功的 Authentication 中提取出用户名/密码。 由于登录成功之后，密码可能被擦除了，所以，如果一开始没有拿到密码，就再从 UserDetailsService 中重新加载用户并重新获取密码。 再接下来去获取令牌的有效期，令牌有效期默认就是两周。 再接下来调用 makeTokenSignature 方法去计算散列值，实际上就是根据 username、令牌有效期以及 password、key 一起计算一个散列值。如果我们没有自己去设置这个 key，默认是在 RememberMeConfigurer#getKey 方法中进行设置的，它的值是一个 UUID 字符串。 最后，将用户名、令牌有效期以及计算得到的散列值放入 Cookie 中。 问题由于我们自己没有设置 key，key 默认值是一个 UUID 字符串，这样会带来一个问题，就是如果服务端重启，这个 key 会变，这样就导致之前派发出去的所有 remember-me 自动登录令牌失效，所以，我们可以指定这个 key。指定方式如下： 123456789101112@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .anyRequest().authenticated() .and() .formLogin() .and() .rememberMe() .key(&quot;javaboy&quot;) .and() .csrf().disable();&#125; 解析的过程 提取出 cookie 信息，并对 cookie 信息进行解码，解码之后，再调用 processAutoLoginCookie 方法去做校验，processAutoLoginCookie 方法的代码我就不贴了，核心流程就是首先获取用户名和过期时间，再根据用户名查询到用户密码，然后通过 MD5 散列函数计算出散列值，再将拿到的散列值和浏览器传递来的散列值进行对比，就能确认这个令牌是否有效，进而确认登录是否有效。 持久化令牌持久化令牌就是在基本的自动登录功能基础上，又增加了新的校验参数，来提高系统的安全性，这一些都是由开发者在后台完成的，对于用户来说，登录体验和普通的自动登录体验是一样的。 在持久化令牌中，新增了两个经过 MD5 散列函数计算的校验参数，一个是 series，另一个是 token。 series 只有当用户在使用用户名/密码登录时，才会生成或者更新 token 只要有新的会话，就会重新生成，这样就可以避免一个用户同时在多端登录， 持久化令牌的具体处理类在PersistentTokenBasedRememberMeServices 类中进行具体处理","categories":[{"name":"java","slug":"java","permalink":"http://wajj.xin/categories/java/"},{"name":"Spring Security","slug":"java/Spring-Security","permalink":"http://wajj.xin/categories/java/Spring-Security/"},{"name":"SpringBoot","slug":"java/Spring-Security/SpringBoot","permalink":"http://wajj.xin/categories/java/Spring-Security/SpringBoot/"}],"tags":[{"name":"java","slug":"java","permalink":"http://wajj.xin/tags/java/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"http://wajj.xin/tags/Spring-Security/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://wajj.xin/tags/SpringBoot/"}]}],"categories":[{"name":"java","slug":"java","permalink":"http://wajj.xin/categories/java/"},{"name":"Quartz","slug":"java/Quartz","permalink":"http://wajj.xin/categories/java/Quartz/"},{"name":"Linux","slug":"Linux","permalink":"http://wajj.xin/categories/Linux/"},{"name":"nginx","slug":"Linux/nginx","permalink":"http://wajj.xin/categories/Linux/nginx/"},{"name":"mysql","slug":"mysql","permalink":"http://wajj.xin/categories/mysql/"},{"name":"mybatis","slug":"java/mybatis","permalink":"http://wajj.xin/categories/java/mybatis/"},{"name":"Spring Security","slug":"java/Spring-Security","permalink":"http://wajj.xin/categories/java/Spring-Security/"},{"name":"SpringBoot","slug":"java/Spring-Security/SpringBoot","permalink":"http://wajj.xin/categories/java/Spring-Security/SpringBoot/"}],"tags":[{"name":"java","slug":"java","permalink":"http://wajj.xin/tags/java/"},{"name":"Quartz","slug":"Quartz","permalink":"http://wajj.xin/tags/Quartz/"},{"name":"Linux","slug":"Linux","permalink":"http://wajj.xin/tags/Linux/"},{"name":"nginx","slug":"nginx","permalink":"http://wajj.xin/tags/nginx/"},{"name":"mysql","slug":"mysql","permalink":"http://wajj.xin/tags/mysql/"},{"name":"mybatis","slug":"mybatis","permalink":"http://wajj.xin/tags/mybatis/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"http://wajj.xin/tags/Spring-Security/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://wajj.xin/tags/SpringBoot/"}]}