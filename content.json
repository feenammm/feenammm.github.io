{"meta":{"title":"阿巴巴巴","subtitle":null,"description":null,"author":"wxy","url":"http://wajj.xin","root":"/"},"pages":[{"title":"友情链接","date":"2021-04-15T01:22:16.594Z","updated":"2021-04-14T15:47:20.000Z","comments":true,"path":"links/index.html","permalink":"http://wajj.xin/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-04-15T01:22:16.596Z","updated":"2021-04-14T15:47:20.000Z","comments":false,"path":"repository/index.html","permalink":"http://wajj.xin/repository/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-04-15T01:22:16.588Z","updated":"2021-04-14T15:47:20.000Z","comments":false,"path":"categories/index.html","permalink":"http://wajj.xin/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-04-15T01:22:16.599Z","updated":"2021-04-14T15:47:20.000Z","comments":false,"path":"tags/index.html","permalink":"http://wajj.xin/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"DOM","slug":"前端/JavaScript/DOM","date":"2021-06-02T13:55:58.000Z","updated":"2021-06-02T13:56:03.972Z","comments":true,"path":"2021/06/02/前端/JavaScript/DOM/","link":"","permalink":"http://wajj.xin/2021/06/02/%E5%89%8D%E7%AB%AF/JavaScript/DOM/","excerpt":"","text":"DOMthis的情况： 当以函数的形式调用时，this是 window 以方法的形式调用时，谁调用方法this就是谁 当以构造函数的形式调用时，this就是新创建的那个对象 使用call或者apply调用时,this就是指定的对象 方法 对象.方法() 谁调用方法this就是谁 函数 方法() this是 window","categories":[{"name":"DOM","slug":"DOM","permalink":"http://wajj.xin/categories/DOM/"}],"tags":[{"name":"DOM","slug":"DOM","permalink":"http://wajj.xin/tags/DOM/"}]},{"title":"Groovy","slug":"java/Groovy/Groovy","date":"2021-05-21T15:35:34.000Z","updated":"2021-05-21T16:06:22.682Z","comments":true,"path":"2021/05/21/java/Groovy/Groovy/","link":"","permalink":"http://wajj.xin/2021/05/21/java/Groovy/Groovy/","excerpt":"","text":"GroovyGroovy是用于Java虛拟机的一种敏捷的动态语言，它是一种成熟的面向对象编程语言，既可以用于面向对象编程，又可以用作纯粹的脚本语言。使用该种语言不必编写过多的代码，同时又具有闭包和动态语言中的其他特性。 特性 Groovy完全兼容java 分号是可选的 类/方法默认是public修饰 编译器会自动给属性添加getter/setter方法 属性可以通过.直接获取 最后一个表达式的值会作为返回值 ==相当于java中的equals方法 没有NullPointerException 自带assert语句 assert version == 2 类型是可选的,会进行推导 def version = 1 方法括号是可选的 println(version) println version 字符串有三种表达形式 def s1 = ‘abc’ //字符串 def s2 = ‘abc ${version}’ //可以添加变量 def s3 = ‘’’def ​ abc ​ ahfd ‘’’ //可以换行 集合API list (java中的ArrayList) 定义 def list = [‘abc’,’def’] 添加元素 list &lt;&lt; ‘ghi’ 长度 list.size() map (java中的LinkedHashMap) 定义 def map = [‘abc’:123,’def’:345] 添加 map.adsabd = 1245 获取 println map.abc print map[‘def’] 闭包 就是一个代码块,和方法一样,可以有参数,可以被赋值给变量,也可以传递给方法,也可以像普通方法一样调用 123456789101112131415161718192021&#x2F;&#x2F; 带参数闭包def a &#x3D; &#123; v -&gt; &#x2F;&#x2F; 参数 print v &#x2F;&#x2F;方法体&#125;&#x2F;&#x2F; 不带参闭包def b &#x3D; &#123; print &#39;hello&#39;&#125;&#x2F;&#x2F; 使用闭包的方法def method1(Closure c)&#123; &#x2F;&#x2F;不导包,导包会导入java包 c(&#39;param&#39;) &#x2F;&#x2F;定义参数&#125;def method2(Closure c)&#123; c()&#125;&#x2F;&#x2F;执行闭包参数method1(a)method2(b) 脚本每个gradle脚本都有一个project实例,所有代码默认作用域都是project 123456789101112131415&#x2F;&#x2F; 构建脚本中是有一个默认的project实例&#x2F;&#x2F; apply是project中的一个方法省略了括号apply plugin:&#39;java&#39; &#x2F;&#x2F;命名参数plugin值为java&#x2F;&#x2F; repositories是一个掉用了闭包参数的方法&#x2F;&#x2F; 仓库管理repositories&#123; mavenCentral()&#125;&#x2F;&#x2F; dependencies是一个掉用了闭包参数的方法&#x2F;&#x2F; 用于依赖管理dependencies&#123; compile &#39;commons-codec:commons-codec:1.6&#39;&#125;","categories":[{"name":"Gradle","slug":"Gradle","permalink":"http://wajj.xin/categories/Gradle/"}],"tags":[{"name":"Gradle","slug":"Gradle","permalink":"http://wajj.xin/tags/Gradle/"}]},{"title":"JavaScript","slug":"前端/JavaScript/JavaScript","date":"2021-05-19T01:21:19.000Z","updated":"2021-05-19T15:04:51.365Z","comments":true,"path":"2021/05/19/前端/JavaScript/JavaScript/","link":"","permalink":"http://wajj.xin/2021/05/19/%E5%89%8D%E7%AB%AF/JavaScript/JavaScript/","excerpt":"","text":"JavaScriptthis的情况： 当以函数的形式调用时，this是 window 以方法的形式调用时，谁调用方法this就是谁 当以构造函数的形式调用时，this就是新创建的那个对象 使用call或者apply调用时,this就是指定的对象 方法 对象.方法() 谁调用方法this就是谁 函数 方法() this是 window","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wajj.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wajj.xin/tags/JavaScript/"}]},{"title":"Lambda","slug":"java/java8新特性/Lambda","date":"2021-05-09T01:03:03.000Z","updated":"2021-05-09T01:55:11.827Z","comments":true,"path":"2021/05/09/java/java8新特性/Lambda/","link":"","permalink":"http://wajj.xin/2021/05/09/java/java8%E6%96%B0%E7%89%B9%E6%80%A7/Lambda/","excerpt":"","text":"Lambdahttps://www.zhihu.com/question/20125256/answer/324121308 Lambda 表达式，也可称为闭包，它允许把函数作为一个方法的参数（函数作为参数传递进方法中）。 作用使用 Lambda 表达式可以使代码变的更加简洁紧凑。 结构Lambda表达式函数只有参数列表，和方法体； ( 参数列表 ) -&gt; { 方法体 } 说明： ( ) ：用来描述参数列表； { } ： 用来描述方法体； -&gt; ：Lambda运算符，可以叫做箭头符号，或者goes to () -&gt; {}，等同于 new Interface(){} 精简语法 参数类型可以省略 假如只有一个参数，()括号可以省略,会推断类型 如果方法体只有一条语句，{}大括号可以省略 如果方法体中唯一的语句是return返回语句，那省略大括号的同时return也要省略 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 无参数无返回值If1 if1=()-&gt;&#123; System.out.println(&quot;无参数无返回值&quot;);&#125;;//精简If1 if1=()-&gt;System.out.println(&quot;无参数无返回值&quot;);if1.test();// 单个参数无返回值If2 if2=(int a)-&gt;&#123; System.out.println(&quot;单个参数无返回值 a=&quot;+a);&#125;;// 精简If2 if2=a-&gt;System.out.println(&quot;单个参数无返回值 a=&quot;+a);if2.test(3);// 两个参数无返回值If3 if3=(int a,int b)-&gt;&#123; System.out.println(&quot;两个参数无返回值 a+b=&quot;+(a+b));&#125;;// 精简If3 if3=(a,b)-&gt;&#123; System.out.println(&quot;两个参数无返回值 a+b=&quot;+(a+b));&#125;;if3.test(2,3);// 无参数有返回值If4 if4=()-&gt;&#123; System.out.print(&quot;无参数有返回值 &quot;); return 100;&#125;;// 精简If4 if4=()-&gt;100;System.out.println(if4.test());// 单个参数有返回值If5 if5=(int a)-&gt;&#123; System.out.print(&quot;单个参数有返回值 &quot;); return a;&#125;;// 精简If5 if5=a-&gt;&#123; System.out.print(&quot;单个参数有返回值 &quot;); return a;&#125;;System.out.println(if5.test(200));// 多个参数有返回值 参数类型可以省略If6 if6=(int a,int b)-&gt;&#123; System.out.print(&quot;多个参数有返回值 &quot;); return a+b;&#125;;// 精简If6 if6=(a,b)-&gt;a+b;System.out.println(if6.test(1,2)); 方法引用方法引用通过方法的名字来指向一个方法,使语言的构造更紧凑简洁，减少冗余代码 语法是：对象::方法 假如是static方法，可以直接 类名::方法 构造方法引用如果函数式接口的实现恰好可以通过调用一个类的构造方法来实现， 那么就可以使用构造方法引用; 语法：类名::new 函数式接口函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。 函数式接口可以被隐式转换为 lambda 表达式。 可以添加@FunctionalInterface 特点 接口有且仅有一个抽象方法 允许定义静态方法 允许定义默认方法 允许java.lang.Object中的public方法 该注解不是必须的，如果一个接口符合”函数式接口”定义，那么加不加该注解都没有影响。加上该注解能够更好地让编译器进行检查。如果编写的不是函数式接口，但是加上了@FunctionInterface，那么编译器会报错","categories":[{"name":"Java8","slug":"Java8","permalink":"http://wajj.xin/categories/Java8/"}],"tags":[{"name":"Lambda","slug":"Lambda","permalink":"http://wajj.xin/tags/Lambda/"},{"name":"Java8","slug":"Java8","permalink":"http://wajj.xin/tags/Java8/"}]},{"title":"abbb","slug":"java/abbb","date":"2021-05-08T06:56:36.000Z","updated":"2021-05-25T08:37:40.428Z","comments":true,"path":"2021/05/08/java/abbb/","link":"","permalink":"http://wajj.xin/2021/05/08/java/abbb/","excerpt":"","text":"abbb泛型的作用 类型安全 在编译时可以进行强类型检查,消除可能出现的错误 可以避免强制类型转换,防止出现ClassCastException 可以实现代码复用 使用场景 ​ 集合 ​ 泛型类(封装返回参数) ​ 泛型接口 ​ 泛型方法","categories":[{"name":"Java","slug":"Java","permalink":"http://wajj.xin/categories/Java/"}],"tags":[{"name":"abbb","slug":"abbb","permalink":"http://wajj.xin/tags/abbb/"}]},{"title":"DateTimeFormatter","slug":"java/java8新特性/时间","date":"2021-05-08T06:56:36.000Z","updated":"2021-06-02T09:04:52.168Z","comments":true,"path":"2021/05/08/java/java8新特性/时间/","link":"","permalink":"http://wajj.xin/2021/05/08/java/java8%E6%96%B0%E7%89%B9%E6%80%A7/%E6%97%B6%E9%97%B4/","excerpt":"","text":"时间类JDK8新特性里提供了3个时间类：LocalDate、LocalTime、LocalDateTime Instant：瞬时实例。 LocalDate：本地日期，不包含具体时间。 LocalTime：本地时间，不包含日期。 LocalDateTime：组合了日期和时间，但不包含时差和时区信息。 ZonedDateTime：最完整的日期时间，包含时区和相对UTC或格林威治的时差。 如果需要对Date类型进行格式，否则可读性很差，格式化Date类型要使用SimpleDateFormat，但SimpleDateFormat是现成不安全的 LocalDateLocalDate是日期处理类 12345678910111213141516// 获取当前日期LocalDate now = LocalDate.now();// 设置日期LocalDate localDate = LocalDate.of(2019, 9, 10);// 获取年int year = localDate.getYear(); //结果：2019int year1 = localDate.get(ChronoField.YEAR); //结果：2019// 获取月Month month = localDate.getMonth(); // 结果：SEPTEMBERint month1 = localDate.get(ChronoField.MONTH_OF_YEAR); //结果：9// 获取日int day = localDate.getDayOfMonth(); //结果：10int day1 = localDate.get(ChronoField.DAY_OF_MONTH); // 结果：10// 获取星期DayOfWeek dayOfWeek = localDate.getDayOfWeek(); //结果：TUESDAYint dayOfWeek1 = localDate.get(ChronoField.DAY_OF_WEEK); //结果：2 LocalTimeLocalTime是时间处理类 12345678910111213// 获取当前时间LocalTime now = LocalTime.now();// 设置时间LocalTime localTime = LocalTime.of(13, 51, 10);//获取小时int hour = localTime.getHour(); // 结果：13int hour1 = localTime.get(ChronoField.HOUR_OF_DAY); // 结果：13//获取分int minute = localTime.getMinute(); // 结果：51int minute1 = localTime.get(ChronoField.MINUTE_OF_HOUR); // 结果：51//获取秒int second = localTime.getSecond(); // 结果：10int second1 = localTime.get(ChronoField.SECOND_OF_MINUTE); // 结果：10 LocalDateTimeLocalDateTime可以设置年月日时分秒，相当于LocalDate + LocalTime 1234567891011// 获取当前日期时间LocalDateTime localDateTime = LocalDateTime.now();// 设置日期LocalDateTime localDateTime1 = LocalDateTime.of(2019, Month.SEPTEMBER, 10, 14, 46, 56);LocalDateTime localDateTime2 = LocalDateTime.of(localDate, localTime);LocalDateTime localDateTime3 = localDate.atTime(localTime);LocalDateTime localDateTime4 = localTime.atDate(localDate);// 获取LocalDateLocalDate localDate2 = localDateTime.toLocalDate();// 获取LocalTimeLocalTime localTime2 = localDateTime.toLocalTime(); Instant123456&#x2F;&#x2F; 创建Instant对象Instant instant &#x3D; Instant.now();&#x2F;&#x2F; 获取秒long currentSecond &#x3D; instant.getEpochSecond();&#x2F;&#x2F; 获取毫秒long currentMilli &#x3D; instant.toEpochMilli(); 如果只是为了获取秒数或者毫秒数，使用System.currentTimeMillis()来得更为方便 修改LocalDate、LocalTime、LocalDateTime、Instant LocalDate、LocalTime、LocalDateTime、Instant为不可变对象，修改这些对象对象会返回一个副本 123456789101112131415161718//创建日期：2019-09-10 14:46:56LocalDateTime localDateTime = LocalDateTime.of(2019, Month.SEPTEMBER, 10, 14, 46, 56);//增加一年localDateTime = localDateTime.plusYears(1); //结果： 2020-09-10 14:46:56localDateTime = localDateTime.plus(1, ChronoUnit.YEARS); //结果： 2021-09-10 14:46:56//减少一个月localDateTime = localDateTime.minusMonths(1); //结果： 2021-08-10 14:46:56localDateTime = localDateTime.minus(1, ChronoUnit.MONTHS); //结果： 2021-07-10 14:46:56//通过with修改某些值，年月日时分秒都可以通过with方法设置。//修改年为2019localDateTime = localDateTime.withYear(2020);//修改为2022localDateTime = localDateTime.with(ChronoField.YEAR, 2022);//日期计算。比如有些时候想知道这个月的最后一天是几号、下个周末是几号，通过提供的时间和日期API可以很快得到答案 。TemporalAdjusters提供的各种日期时间格式化的静态类，比如firstDayOfYear是当前日期所属年的第一天LocalDate localDate = LocalDate.now();LocalDate localDate1 = localDate.with(TemporalAdjusters.firstDayOfYear()); Zoned通过指定的时区处理日期时间 DateTimeFormatter在java8之前使用SimpleDateFormat类来进行时间格式化，但这种存在一些缺点： 每处理一次时间都new一个SimpleDateFormat实例对象会占用大量的内存和jvm空间 为了减少内存开销，我们可以使用static将其设置为共享变量，但SimpleDateFormat是线程不安全的，需要通过加锁的方式来解决 java8之后为我们提供了DateTimeFormatter类代替SimpleDateFormat，这是一个线程安全的格式化工具类。 1DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm&quot;); 字符串转换为日期123String dateStr= &quot;2018年12月18日&quot;;DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日&quot;);LocalDate date= LocalDate.parse(dateStr, formatter); 日期转换为字符串123LocalDateTime now = LocalDateTime.now();DateTimeFormatter format = DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);String nowStr = now.format(format); 日期转LocalDateTime12DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);LocalDateTime.parse(&quot;2017-08-11 01:00:00&quot;, formatter);","categories":[{"name":"Java8","slug":"Java8","permalink":"http://wajj.xin/categories/Java8/"}],"tags":[{"name":"Java8","slug":"Java8","permalink":"http://wajj.xin/tags/Java8/"},{"name":"DateTimeFormatter","slug":"DateTimeFormatter","permalink":"http://wajj.xin/tags/DateTimeFormatter/"}]},{"title":"stream","slug":"java/java8新特性/stream","date":"2021-05-08T06:56:36.000Z","updated":"2021-05-29T01:46:59.822Z","comments":true,"path":"2021/05/08/java/java8新特性/stream/","link":"","permalink":"http://wajj.xin/2021/05/08/java/java8%E6%96%B0%E7%89%B9%E6%80%A7/stream/","excerpt":"","text":"streamhttp://blog.csdn.net/IO_Field/article/details/54971761 https://www.cnblogs.com/xiaoxiongcanguan/p/10511233.html 定义数据 1234567891011Student stuA = new Student(1, &quot;A&quot;, &quot;M&quot;, 184);Student stuB = new Student(2, &quot;B&quot;, &quot;G&quot;, 163);Student stuC = new Student(3, &quot;C&quot;, &quot;M&quot;, 175);Student stuD = new Student(4, &quot;D&quot;, &quot;G&quot;, 158);Student stuE = new Student(5, &quot;E&quot;, &quot;M&quot;, 170);List&lt;Student&gt; list = new ArrayList&lt;&gt;();list.add(stuA);list.add(stuB);list.add(stuC);list.add(stuD);list.add(stuE); 获取Sex=“G”的Student，并打印出来 新老对比外部迭代 原来的处理模式，必然会想到一个for循环就搞定了，而在for循环其实是一个封装了迭代的语法块。在这里使用Iterator进行迭代： 12345678Iterator&lt;Student&gt; iterator = list.iterator();while(iterator.hasNext()) &#123; Student stu = iterator.next(); if (stu.getSex().equals(&quot;G&quot;)) &#123; System.out.println(stu.toString()); &#125;&#125; 调用过程: 整个迭代过程是这样的：首先调用iterator方法，产生一个新的Iterator对象，进而控制整 个迭代过程，这就是外部迭代 迭代过程通过显式调用Iterator对象的hasNext和next方法完成迭代 java8 内部迭代 123list.stream() .filter(student -&gt; student.getSex().equals(&quot;G&quot;)) .forEach(student -&gt; System.out.println(student.toString())); 调用过程 1首先，通过stream方法创建Stream，然后再通过filter方法对源数据进行过滤，最后通过foeEach方法进行迭代。在聚合操作中，与Labda表达式一起使用，显得代码更加的简洁。这里值得注意的是，我们首先是stream方法的调用，其与iterator作用一样的作用一样，该方法不是返回一个控制迭代的 Iterator 对象，而是返回内部迭代中的相应接口： Stream，其一系列的操作都是在操作Stream,直到feach时才会操作结果，这种迭代方式称为内部迭代。 区别 迭代器提供next()、hasNext()等方法，开发者可以自行控制对元素的处理，以及处理方式，但是只能顺序处理； stream()方法返回的数据集无next()等方法，开发者无法控制对元素的迭代，迭代方式是系统内部实现的，同时系统内的迭代也不一定是顺序的，还可以并行，如parallelStream()方法。并行的方式在一些情况下，可以大幅提升处理的效率。 组成部分 创建Stream:通过stream()方法，取得集合对象的数据集。 Intermediate:通过一系列中间（Intermediate）方法，对数据集进行过滤、检索等数据集的再次处理。如上例中，使用filter()方法来对数据集进行过滤。 Terminal通过最终（terminal）方法完成对数据集中元素的处理。如上例中，使用forEach()完成对过滤后元素的打印。 在一次聚合操作中，可以有多个Intermediate，但是有且只有一个Terminal 在对一个Stream可以进行多次转换操作，并不是每次都对Stream的每个元素执行转换。转换操作是lazy(惰性求值)的，只有在Terminal操作执行时，才会一次性执行。可以这么认为，Stream 里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在 Terminal 操作的时候循环 Stream 对应的集合，然后对每个元素执行所有的函数。 并不像for循环中，循环N次，其时间复杂度就是N。 操作分类 Intermediate：map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 skip、 parallel、 sequential、 unordered Terminal：forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、iterator Short-circuiting：anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit 惰性求值和及早求值方法像filter这样只描述Stream，最终不产生新集合的方法叫作惰性求值方法；而像count这样最终会从Stream产生值的方法叫作及早求值方法。 123456long count = allArtists.stream() .filter(artist -&gt; &#123; System.out.println(artist.getName()); return artist.isFrom(&quot;London&quot;); &#125;) .count(); 如果返回值是Stream，那么就是惰性求值； 如果返回值不是Stream或者是void，那么就是及早求值。 在一个Stream操作中，可以有多次惰性求值，但有且仅有一次及早求值。上面的示例中，只是包含两步：一个惰性求值-filter和一个及早求值-count。 创建Stream我们有多种方式生成Stream: Stream接口的静态工厂方法（注意：Java8里接口可以带静态方法）； Collection接口和数组的默认方法（默认方法,也使Java的新特性之一，后续介绍），把一个Collection对象转换成Stream 其他 Random.ints() BitSet.stream() Pattern.splitAsStream(java.lang.CharSequence) JarFile.stream() 静态工厂方法ofof方法，其生成的Stream是有限长度的，Stream的长度为其内的元素个数。 12- of(T... values)：返回含有多个T元素的Stream- of(T t)：返回含有一个T元素的Stream 示例： 12Stream&lt;Integer&gt; integerStream = Stream.of(1, 2, 3);Stream&lt;String&gt; stringStream = Stream.of(&quot;A&quot;); generatorgenerator方法，返回一个无限长度的Stream,其元素由Supplier接口的提供。在Supplier是一个函数接口，只封装了一个get()方法，其用来返回任何泛型的值，该结果在不同的时间内，返回的可能相同也可能不相同，没有特殊的要求。 1- generate(Supplier&lt;T&gt; s)：返回一个无限长度的Stream 这种情形通常用于随机数、常量的 Stream，或者需要前后元素间维持着某种状态信息的 Stream。 把 Supplier 实例传递给 Stream.generate() 生成的 Stream，默认是串行（相对 parallel 而言）但无序的（相对 ordered 而言）。 示例： 123456789Stream&lt;Double&gt; generateA = Stream.generate(new Supplier&lt;Double&gt;() &#123; @Override public Double get() &#123; return java.lang.Math.random(); &#125;&#125;);Stream&lt;Double&gt; generateB = Stream.generate(()-&gt; java.lang.Math.random());Stream&lt;Double&gt; generateC = Stream.generate(java.lang.Math::random); 以上三种形式达到的效果是一样的，只不过是下面的两个采用了Lambda表达式，简化了代码，其实际效果就是返回一个随机值。一般无限长度的Stream会与filter、limit等配合使用，否则Stream会无限制的执行下去，后果可想而知，如果你有兴趣，不妨试一下。 iterateiterate方法，其返回的也是一个无限长度的Stream，与generate方法不同的是，其是通过函数f迭代对给指定的元素种子而产生无限连续有序Stream，其中包含的元素可以认为是：seed，f(seed),f(f(seed))无限循环。 1- iterate(T seed, UnaryOperator&lt;T&gt; f) 示例： 1234Stream.iterate(1, item -&gt; item + 1) .limit(10) .forEach(System.out::println); // 打印结果：1，2，3，4，5，6，7，8，9，10 上面示例，种子为1，也可认为该Stream的第一个元素，通过f函数来产生第二个元素。接着，第二个元素，作为产生第三个元素的种子，从而产生了第三个元素，以此类推下去。需要主要的是，该Stream也是无限长度的，应该使用filter、limit等来截取Stream，否则会一直循环下去。 emptyempty方法返回一个空的顺序Stream，该Stream里面不包含元素项。 1Stream.empty(); Stream.concat()合成两个流 Collection接口和数组的默认方法在Collection接口中，定义了一个默认方法stream()，用来生成一个Stream。 12345public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123; default Stream&lt;E&gt; stream() &#123; return StreamSupport.stream(spliterator(), false); &#125;&#125; 在Arrays类，封装了一些列的Stream方法，不仅针对于任何类型的元素采用了泛型，更对于基本类型作了相应的封装，以便提升Stream的处理效率。 1234567891011public class Arrays &#123; *** public static &lt;T&gt; Stream&lt;T&gt; stream(T[] array) &#123; return stream(array, 0, array.length); &#125; public static LongStream stream(long[] array) &#123; return stream(array, 0, array.length); &#125; *** ｝ 示例： 123int ids[] = new int[]&#123;1, 2, 3, 4&#125;;Arrays.stream(ids) .forEach(System.out::println); 其他 Random.ints() BitSet.stream() Pattern.splitAsStream(java.lang.CharSequence) JarFile.stream() IntermediateIntermediate主要是用来对Stream做出相应转换及限制流，实际上是将源Stream转换为一个新的Stream，以达到需求效果。 concatconcat方法将两个Stream连接在一起，合成一个Stream。若两个输入的Stream都时排序的，则新Stream也是排序的；若输入的Stream中任何一个是并行的，则新的Stream也是并行的；若关闭新的Stream时，原两个输入的Stream都将执行关闭处理。 示例： 1234Stream.concat(Stream.of(1, 2, 3), Stream.of(4, 5)) .forEach(integer -&gt; System.out.print(integer + &quot; &quot;));// 打印结果// 1 2 3 4 5 distinctdistinct方法以达到去除掉原Stream中重复的元素，生成的新Stream中没有没有重复的元素。 123Stream.of(1,2,3,1,2,3) .distinct() .forEach(System.out::println); // 打印结果：1，2，3 创建了一个Stream（命名为A），其含有重复的1，2，3等六个元素，而实际上打印结果只有“1，2，3”等3个元素。因为A经过distinct去掉了重复的元素，生成了新的Stream（命名为B），而B中只有“1，2，3”这三个元素，所以也就呈现了刚才所说的打印结果。 filterfilter方法对原Stream按照指定条件过滤，在新建的Stream中，只包含满足条件的元素，将不满足条件的元素过滤掉。 示例： 123Stream.of(1, 2, 3, 4, 5) .filter(item -&gt; item &gt; 3) .forEach(System.out::println);// 打印结果：4，5 创建了一个含有1，2，3，4，5等5个整型元素的Stream,filter中设定的过滤条件为元素值大于3，否则将其过滤。而实际的结果为4，5。 filter传入的Lambda表达式必须是Predicate实例，参数可以为任意类型，而其返回值必须是boolean类型。 mapmap方法将对于Stream中包含的元素使用给定的转换函数进行转换操作，新生成的Stream只包含转换生成的元素。为了提高处理效率，官方已封装好了，三种变形：mapToDouble，mapToInt，mapToLong。其实很好理解，如果想将原Stream中的数据类型，转换为double,int或者是long是可以调用相对应的方法。 示例： 12345Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;hello&quot;) .map(item-&gt; item.toUpperCase()) .forEach(System.out::println);// 打印结果// A, B, HELLO 传给map中Lambda表达式，接受了String类型的参数，返回值也是String类型，在转换行数中，将字母全部改为大写 map传入的Lambda表达式必须是Function实例，参数可以为任意类型，而其返回值也是任性类型，javac会根据实际情景自行推断。 flatMapflatMap方法与map方法类似，都是将原Stream中的每一个元素通过转换函数转换，不同的是，该换转函数的对象是一个Stream，也不会再创建一个新的Stream，而是将原Stream的元素取代为转换的Stream。如果转换函数生产的Stream为null，应由空Stream取代。flatMap有三个对于原始类型的变种方法，分别是：flatMapToInt，flatMapToLong和flatMapToDouble。 示例： 12345Stream.of(1, 2, 3) .flatMap(integer -&gt; Stream.of(integer * 10)) .forEach(System.out::println);// 打印结果// 10，20，30 传给flatMap中的表达式接受了一个Integer类型的参数，通过转换函数，将原元素乘以10后，生成一个只有该元素的流，该流取代原流中的元素。 flatMap传入的Lambda表达式必须是Function实例，参数可以为任意类型，而其返回值类型必须是一个Stream。 peekpeek方法生成一个包含原Stream的所有元素的新Stream，同时会提供一个消费函数（Consumer实例），新Stream每个元素被消费的时候都会执行给定的消费函数，并且消费函数优先执行 示例： 1234567891011121314Stream.of(1, 2, 3, 4, 5) .peek(integer -&gt; System.out.println(&quot;accept:&quot; + integer)) .forEach(System.out::println);// 打印结果// accept:1// 1// accept:2// 2// accept:3// 3// accept:4// 4// accept:5// 5 skipskip方法将过滤掉原Stream中的前N个元素，返回剩下的元素所组成的新Stream。如果原Stream的元素个数大于N，将返回原Stream的后（原Stream长度-N）个元素所组成的新Stream；如果原Stream的元素个数小于或等于N，将返回一个空Stream。 示例： 12345Stream.of(1, 2, 3,4,5) .skip(2) .forEach(System.out::println);// 打印结果// 3,4,5 sortedsorted方法将对原Stream进行排序，返回一个有序列的新Stream。sorterd有两种变体sorted()，sorted(Comparator)，前者将默认使用Object.equals(Object)进行排序，而后者接受一个自定义排序规则函数(Comparator)，可按照意愿排序。 示例： 1234567891011Stream.of(5, 4, 3, 2, 1) .sorted() .forEach(System.out::println);// 打印结果// 1，2，3,4,5Stream.of(1, 2, 3, 4, 5) .sorted() .forEach(System.out::println);// 打印结果// 5, 4, 3, 2, 1 TerminalcollectJava 8系列之Stream的强大工具CollectorJava 8系列之重构和定制收集器 countcount方法将返回Stream中元素的个数。 示例： 123long count = Stream.of(1, 2, 3, 4, 5) .count();System.out.println(&quot;count:&quot; + count);// 打印结果：count:5 forEachforEach方法前面已经用了好多次，其用于遍历Stream中的所元素，避免了使用for循环，让代码更简洁，逻辑更清晰。 示例： 12345Stream.of(5, 4, 3, 2, 1) .sorted() .forEach(System.out::println);// 打印结果// 1，2，3,4,5 forEachOrderedforEachOrdered方法与forEach类似，都是遍历Stream中的所有元素，不同的是，如果该Stream预先设定了顺序，会按照预先设定的顺序执行（Stream是无序的），默认为元素插入的顺序。 示例： 12345678910Stream.of(5,2,1,4,3) .forEachOrdered(integer -&gt; &#123; System.out.println(&quot;integer:&quot;+integer); &#125;); // 打印结果// integer:5// integer:2// integer:1// integer:4// integer:3 maxmax方法根据指定的Comparator，返回一个Optional，该Optional中的value值就是Stream中最大的元素。至于Optional是啥，后续再做介绍吧。 原Stream根据比较器Comparator，进行排序(升序或者是降序)，所谓的最大值就是从新进行排序的，max就是取重新排序后的最后一个值，而min取排序后的第一个值。 示例： 123Optional&lt;Integer&gt; max = Stream.of(1, 2, 3, 4, 5) .max((o1, o2) -&gt; o2 - o1);System.out.println(&quot;max:&quot; + max.get());// 打印结果：max:1 对于原Stream指定了Comparator，实际上是找出该Stream中的最小值，不过，在max方法中找最小值，更能体现出来Comparator的作用吧。max的值不言而喻，就是1了。 minmin方法根据指定的Comparator，返回一个Optional，该Optional中的value值就是Stream中最小的元素。至于Optional是啥，后续再做介绍吧。 示例： 123Optional&lt;Integer&gt; max = Stream.of(1, 2, 3, 4, 5) .max((o1, o2) -&gt; o1 - o2);System.out.println(&quot;max:&quot; + max.get());// 打印结果：min:5 刚才在max方法中，我们找的是Stream中的最小值，在min中我们找的是Stream中的最大值，不管是最大值还是最小值起决定作用的是Comparator，它决定了元素比较大小的原则。 reduceJava 8系列之Stream中万能的reduce Short-circuitingallMatchallMatch操作用于判断Stream中的元素是否全部满足指定条件。如果全部满足条件返回true，否则返回false。 示例： 123boolean allMatch = Stream.of(1, 2, 3, 4) .allMatch(integer -&gt; integer &gt; 0);System.out.println(&quot;allMatch: &quot; + allMatch); // 打印结果：allMatch: true anyMatchanyMatch操作用于判断Stream中的是否有满足指定条件的元素。如果最少有一个满足条件返回true，否则返回false。 示例： 123boolean anyMatch = Stream.of(1, 2, 3, 4) .anyMatch(integer -&gt; integer &gt; 3);System.out.println(&quot;anyMatch: &quot; + anyMatch); // 打印结果：anyMatch: true findAnyfindAny操作用于获取含有Stream中的某个元素的Optional，如果Stream为空，则返回一个空的Optional。由于此操作的行动是不确定的，其会自由的选择Stream中的任何元素。在并行操作中，在同一个Stram中多次调用，可能会不同的结果。在串行调用时，Debug了几次，发现每次都是获取的第一个元素，个人感觉在串行调用时，应该默认的是获取第一个元素。 示例： 1Optional&lt;Integer&gt; any = Stream.of(1, 2, 3, 4).findAny(); findFirstfindFirst操作用于获取含有Stream中的第一个元素的Optional，如果Stream为空，则返回一个空的Optional。若Stream并未排序，可能返回含有Stream中任意元素的Optional。 示例： 1Optional&lt;Integer&gt; any = Stream.of(1, 2, 3, 4).findFirst(); limitlimit方法将截取原Stream，截取后Stream的最大长度不能超过指定值N。如果原Stream的元素个数大于N，将截取原Stream的前N个元素；如果原Stream的元素个数小于或等于N，将截取原Stream中的所有元素。 示例： 12345Stream.of(1, 2, 3,4,5) .limit(2) .forEach(System.out::println);// 打印结果// 1,2 传入limit的值为2，也就是说被截取后的Stream的最大长度为2，又由于原Stream中有5个元素，所以将截取原Stream中的前2个元素，生成一个新的Stream。 noneMatchnoneMatch方法将判断Stream中的所有元素是否满足指定的条件，如果所有元素都不满足条件，返回true；否则，返回false. 示例： 1234567boolean noneMatch = Stream.of(1, 2, 3, 4, 5) .noneMatch(integer -&gt; integer &gt; 10);System.out.println(&quot;noneMatch:&quot; + noneMatch); // 打印结果 noneMatch:trueboolean noneMatch_ = Stream.of(1, 2, 3, 4, 5) .noneMatch(integer -&gt; integer &lt; 3);System.out.println(&quot;noneMatch_:&quot; + noneMatch_); // 打印结果 noneMatch_:false FunctionFunction&lt;T,R&gt;,主要方法： R apply(T t),这是一个修改者 123456789Function&lt;Integer, Integer&gt; incr = new Function&lt;Integer, Integer&gt;() &#123; @Override public Integer apply(Integer i) &#123; //todo:此处业务代码 return i++; &#125;&#125;;//Lambda方式：Function&lt;Integer, Integer&gt; incr = i -&gt; i++; compose()默认方法,优先执行 设置在业务逻辑方法(apply)执行之前的预处理，类似于前置切面，当通过compose方式设置了前置方法，在调用apply时，会先执行compose设置的方法，因此compose设置的方法的入参类型需要和apply的入参类型一致，而compose设置的方法的出参将作为apply方法入参，所以compose设置的方法的出参类型也要和apply方法的入参一致 1234567/** * 先执行参数(也是一个Function)的，再执行调用者(同样是一个Function) */default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) &#123; Objects.requireNonNull(before); return (V v) -&gt; apply(before.apply(v));&#125; Function对象允许通过多次调用compose方法设置多个前置方法，执行顺序是后设置的先执行，类似于栈 1234567891011121314151617181920212223public void testFunction()&#123; Function&lt;String, Integer&gt; func = num -&gt; &#123; System.out.println(&quot;exec function&quot;); return Integer.parseInt(num); &#125;; func = func.compose(getBefore(&quot;b1&quot;)) .compose(getBefore(&quot;b2&quot;)); Integer result = func.apply(&quot;12&quot;); System.out.println(result);&#125;public Function&lt;String, String&gt; getBefore(String name)&#123; return i -&gt; &#123; System.out.println(&quot;before...&quot; + name); return i + &quot;1&quot;; &#125;;&#125;//执行结果before...b2before...b1exec function1211 andThen()稍后执行 设置在业务逻辑方法(apply)执行之后的处理逻辑，类似于后置切面，当通过andThen方式设置了后置方法，在调用apply执行完成之后，会执行andThen设置的方法，因此andThen设置的方法的入参类型需要和apply的出参类型一致，而andThen方法的出参将作为apply方法的最终出参，所以andThen的出参类型也要和apply方法的出参一致。 1234567/** * 先执行调用者，再执行参数，和compose相反。 */default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) &#123; Objects.requireNonNull(after); return (T t) -&gt; after.apply(apply(t));&#125; Function对象允许通过多次调用andThen方法设置多个后置方法，执行顺序是先设置的先执行，和compose相反，类似于队列 1234567891011121314151617181920212223242526public void testFunction()&#123; Function&lt;String, Integer&gt; func = num -&gt; &#123; System.out.println(&quot;exec function&quot;); return Integer.parseInt(num); &#125;; func = func .andThen(getAfter(&quot;a1&quot;)) .andThen(getAfter(&quot;a2&quot;)); Integer result = func.apply(&quot;12&quot;); System.out.println(result);&#125;public Function&lt;Integer, Integer&gt; getAfter(String name)&#123; return i -&gt; &#123; System.out.println(&quot;after...&quot; + name); return i + 1; &#125;;&#125;//执行结果exec functionafter...a1after...a214 identity()identity()是Function接口的一个静态方法,返回一个输出跟输入一样的Lambda表达式对象，等价于形如t -&gt; t形式的Lambda表达式 123static Function identity() &#123; return t -&gt; t;&#125; 123// 将Stream转换成容器或MapStream&lt;String&gt; stream = Stream.of(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;);Map&lt;String, Integer&gt; map = stream.collect(Collectors.toMap(Function.identity(), String::length)); Predicate用于判断 1234/** * 接收一个参数, 判断这个参数是否匹配某种规则, 匹配成功返回true, 匹配失败则返回false */boolean test(T t); 12345678910Predicate&lt;String&gt; predicate = item -&gt; &quot;七夜雪&quot;.equals(item); // 1. test 方法测试 System.out.println(&quot;1---&gt; &quot; + predicate.test(&quot;七夜雪&quot;));List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));// 2. Predicate 返回一个List中的偶数// list.stream(), 表示将List作为流进行处理, filter()方法接收一个Predicate, toArray是将流转换成数组Object[] result = list.stream().filter(t -&gt; t % 2 == 0).toArray();print(&quot;2---&gt; &quot; + Arrays.toString(result)); and()123456789101112/** * default方法, 接收另外一个Predicate&lt;T&gt;类型参数进行逻辑与操作 * 返回一个新的Predicate * Predicate&lt;T&gt; newPredicate = (t) -&gt; this.test(t) &amp;&amp; other.test(t); * 如果传入的Predicate为空, 会抛出空指针异常 * 相当于进行两次判断 * 可理解为 条件A &amp;&amp; 条件B */default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) &#123; Objects.requireNonNull(other); return (t) -&gt; test(t) &amp;&amp; other.test(t);&#125; 12345// 3. 测试Predicate的and方法, 打印list中大于3, 小于6的数字Predicate&lt;Integer&gt; predicate1 = t -&gt; t &gt; 3;predicate1 = predicate1.and(t -&gt; t &lt; 6);result = list.stream().filter(predicate1).toArray();print(&quot;3---&gt; &quot; + Arrays.toString(result)); negata()12345678/** * default方法, 返回当前Predicate取反操作之后的Predicate * Predicate&lt;T&gt; newPredicate = (t) -&gt; !test(t); * 对当前判断进行取反操作，可理解为 !条件A */default Predicate&lt;T&gt; negate() &#123; return (t) -&gt; !test(t);&#125; 123// 5. 测试Predicate的negate方法, 返回list中大于等于3,小于等于5的数字, 即对场景4取反result = list.stream().filter(predicate1.negate()).toArray();print(&quot;5---&gt; &quot; + Arrays.toString(result)); or()1234567891011/** * default方法, 接收另外一个Predicate&lt;T&gt;类型参数进行逻辑或操作 * 返回一个新的Predicate * Predicate&lt;T&gt; newPredicate = (t) -&gt; this.test(t) || other.test(t); * 如果传入的Predicate为空, 会抛出空指针异常 * 对当前判断进行&quot;||&quot;操作,即取或操作,可以理解为 条件A ||条件B */default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) &#123; Objects.requireNonNull(other); return (t) -&gt; test(t) || other.test(t);&#125; 12345// 4. 测试Predicate的or方法, 打印list中小于3或大于5的数字predicate1 = t -&gt; t &lt; 3;predicate1 = predicate1.or(t -&gt; t &gt; 5);result = list.stream().filter(predicate1).toArray();print(&quot;4---&gt; &quot; + Arrays.toString(result)); isEqual()1234567891011/** * 接收一个Object targetRef, 返回一个Predicate&lt;T&gt;类型 * 返回的Predicate的test方法是用来判断传入的参数是否等于targetRef * 如Predicate&lt;T&gt; predicate = Predicate.isEqual(&quot;七夜雪&quot;); * 等同于Predicate&lt;T&gt; predicate = t -&gt; &quot;七夜雪&quot;.equals(t); */static &lt;T&gt; Predicate&lt;T&gt; isEqual(Object targetRef) &#123; return (null == targetRef) ? Objects::isNull : object -&gt; targetRef.equals(object);&#125; 1234// 6. 测试静态方法isEqual方法, 个人感觉这个方法没啥用处predicate = Predicate.isEqual(&quot;七夜雪&quot;);print(&quot;6---&gt; &quot; + predicate.test(&quot;七夜雪&quot;));print(&quot;6---&gt; &quot; + predicate.test(&quot;七夜雪1&quot;)); OptionalOptional 是 Java 语言的有益补充,用于减少代码中的 NullPointerExceptions，虽然还不能完全消除这些异常 ​ Optional 类是一个可以为null的容器对象,可以保存类型T的值，或者仅仅保存null。 ​ Optional提供很多有用的方法，这样我们就不用显式进行空值检测,如果值存在调用isPresent()方法会返回true，调用get()方法会返回该对象 123Optional&lt;A&gt; firstA= AList.stream() .filter(a -&gt; &quot;小明&quot;.equals(a.getUserName())) .findFirst(); isPresent123456if (firstA.isPresent()) &#123; A a = firstA.get(); //这样子就取到了这个对象。&#125;else &#123; //没有查到的逻辑&#125; ifPresent用于对过滤出的数据如果存在。如果经过过滤条件后，有数据的话就可以进行修改。 123456Optional&lt;A&gt; firstA= AList.stream() .filter(a -&gt; &quot;小明&quot;.equals(a.getUserName())) .findFirst() .ifPresent(a -&gt; &#123; a.setUserName(&quot;明明&quot;); &#125;) BiFunction123456789@FunctionalInterfacepublic interface BiFunction&lt;R, T, U&gt; &#123; /** * 函数式接口 * 类似于 z = F(x,y) * */ R apply(T t, U u);&#125; ForEach123456789@FunctionalInterfacepublic interface ForEach &lt;T&gt;&#123; /** * 迭代器遍历 * @param item 被迭代的每一项 * */ void apply(T item);&#125; Comparator12345678910111213@FunctionalInterfacepublic interface Comparator&lt;T&gt; &#123; /** * 比较方法逻辑 * @param o1 参数1 * @param o2 参数2 * @return 返回值大于0 ---&gt; (o1 &gt; o2) * 返回值等于0 ---&gt; (o1 = o2) * 返回值小于0 ---&gt; (o1 &lt; o2) */ int compare(T o1, T o2);&#125; Supplier123456789@FunctionalInterfacepublic interface Supplier&lt;T&gt; &#123; /** * 提供初始值 * @return 初始化的值 * */ T get();&#125; EvalFunction123456789@FunctionalInterfacepublic interface EvalFunction&lt;T&gt; &#123; /** * stream流的强制求值方法 * @return 求值返回一个新的stream * */ MyStream&lt;T&gt; apply();&#125; API123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/** * stream流的API接口 */public interface Stream&lt;T&gt; &#123; /** * 映射 lazy 惰性求值 * @param mapper 转换逻辑 T-&gt;R * @return 一个新的流 * */ &lt;R&gt; MyStream&lt;R&gt; map(Function&lt;R,T&gt; mapper); /** * 扁平化 映射 lazy 惰性求值 * @param mapper 转换逻辑 T-&gt;MyStream&lt;R&gt; * @return 一个新的流(扁平化之后) * */ &lt;R&gt; MyStream&lt;R&gt; flatMap(Function&lt;? extends MyStream&lt;R&gt;, T&gt; mapper); /** * 过滤 lazy 惰性求值 * @param predicate 谓词判断 * @return 一个新的流，其中元素是满足predicate条件的 * */ MyStream&lt;T&gt; filter(Predicate&lt;T&gt; predicate); /** * 截断 lazy 惰性求值 * @param n 截断流，只获取部分 * @return 一个新的流，其中的元素不超过 n * */ MyStream&lt;T&gt; limit(int n); /** * 去重操作 lazy 惰性求值 * @return 一个新的流，其中的元素不重复(!equals） * */ MyStream&lt;T&gt; distinct(); /** * 窥视 lazy 惰性求值 * @return 同一个流，peek不改变流的任何行为 * */ MyStream&lt;T&gt; peek(ForEach&lt;T&gt; consumer); /** * 遍历 eval 强制求值 * @param consumer 遍历逻辑 * */ void forEach(ForEach&lt;T&gt; consumer); /** * 浓缩 eval 强制求值 * @param initVal 浓缩时的初始值 * @param accumulator 浓缩时的 累加逻辑 * @return 浓缩之后的结果 * */ &lt;R&gt; R reduce(R initVal, BiFunction&lt;R, R, T&gt; accumulator); /** * 收集 eval 强制求值 * @param collector 传入所需的函数组合子，生成高阶函数 * @return 收集之后的结果 * */ &lt;R, A&gt; R collect(Collector&lt;T,A,R&gt; collector); /** * 最大值 eval 强制求值 * @param comparator 大小比较逻辑 * @return 流中的最大值 * */ T max(Comparator&lt;T&gt; comparator); /** * 最小值 eval 强制求值 * @param comparator 大小比较逻辑 * @return 流中的最小值 * */ T min(Comparator&lt;T&gt; comparator); /** * 计数 eval 强制求值 * @return 当前流的个数 * */ int count(); /** * 流中是否存在满足predicate的项 * @return true 存在 匹配项 * false 不存在 匹配项 * */ boolean anyMatch(Predicate&lt;? super T&gt; predicate); /** * 流中的元素是否全部满足predicate * @return true 全部满足 * false 不全部满足 * */ boolean allMatch(Predicate&lt;? super T&gt; predicate); /** * 返回空的 stream * @return 空stream * */ static &lt;T&gt; MyStream&lt;T&gt; makeEmptyStream()&#123; // isEnd = true return new MyStream.Builder&lt;T&gt;().isEnd(true).build(); &#125;&#125; 过滤集合123List&lt;A&gt; aList= AList.stream() .filter(a -&gt; &quot;小明&quot;.equals(a.getUserName())) .collect(Collectors.toList()); 1234//去掉名称为空的List&lt;A&gt; aList = AList.stream() .filter(a-&gt; StringUtil.isNotEmpty(a.getName())) .collect(Collectors.toList()); 抽取对象中所有id 123List&lt;Long&gt; idList = AList.stream() .map(A::getId) .collect(Collectors.toList()); 返回map 123Map&lt;Long, A&gt; map = AList.stream() .filter(a-&gt; StringUtil.isNotEmpty(a.getName())) .collect(Collectors.toMap(A::getId, a -&gt; a)); 分组 1.collect(Collectors.groupingBy(实体::get字段))","categories":[{"name":"Java8","slug":"Java8","permalink":"http://wajj.xin/categories/Java8/"}],"tags":[{"name":"stream","slug":"stream","permalink":"http://wajj.xin/tags/stream/"}]},{"title":"自动生成VO-DO的模型映射","slug":"技巧/自动生成VO-DO的模型映射/自动生成VO-DO的模型映射","date":"2021-05-07T07:11:06.000Z","updated":"2021-05-07T07:14:39.584Z","comments":true,"path":"2021/05/07/技巧/自动生成VO-DO的模型映射/自动生成VO-DO的模型映射/","link":"","permalink":"http://wajj.xin/2021/05/07/%E6%8A%80%E5%B7%A7/%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90VO-DO%E7%9A%84%E6%A8%A1%E5%9E%8B%E6%98%A0%E5%B0%84/%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90VO-DO%E7%9A%84%E6%A8%A1%E5%9E%8B%E6%98%A0%E5%B0%84/","excerpt":"","text":"https://my.oschina.net/u/4681730/blog/4817090 添加 mapStruct依赖123456789101112&lt;!--mapStruct依赖 自动生成VO-DO的模型映射--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-jdk8&lt;/artifactId&gt; &lt;version&gt;1.2.0.CR1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt; &lt;version&gt;1.2.0.CR1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 生成DO对象及VO对象DODO对象，表示持久化，DO对象的每个属性都对应表的每个字段 12345678910111213141516171819202122232425/** * 用户实体对应表 mgr_user */@Data@TableName(&quot;mgr_user&quot;)public class User &#123; @TableId(value = &quot;user_id&quot;, type = IdType.AUTO) private Long userId; private String username; private String password; private String name; private String userDesc; private String employeeNo; private String email; @TableLogic private Byte isDeleted; private Long createBy; @TableField(value = &quot;create_time&quot;, fill = FieldFill.INSERT) @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;) private Date createTime; private Long updateBy; @TableField(value = &quot;update_time&quot;, fill = FieldFill.INSERT_UPDATE) private Date updateTime;&#125; VOVO对象，表示视图对象，前端传过来数据封装成一个对象，用于接收前端数据的对象 12345678910111213141516171819202122232425262728293031323334@Data@ApiModel(value = &quot;用户信息&quot;)public class RequestUser &#123; @TableId(value = &quot;user_id&quot;, type = IdType.AUTO) @ApiModelProperty(value = &quot;用户ID&quot;, example = &quot;0&quot;, hidden = true) private Long userId; @ApiModelProperty(value = &quot;登录名&quot;, example = &quot;admin&quot;) private String username; @ApiModelProperty(value = &quot;登录密码&quot;, example = &quot;123456&quot;) private String password; @ApiModelProperty(value = &quot;用户名&quot;, example = &quot;张三&quot;) private String name; @ApiModelProperty(value = &quot;备注&quot;, example = &quot;个性鲜明&quot;) private String userDesc; @ApiModelProperty(value = &quot;员工工号&quot;, example = &quot;10001&quot;) private String employeeNo; @ApiModelProperty(value = &quot;邮箱&quot;, example = &quot;admin@hundsun.com&quot;) private String email; @TableLogic @ApiModelProperty(value = &quot;状态: 0:正常 1:删除&quot;, hidden = true) private Byte isDeleted; @ApiModelProperty(value = &quot;创建者&quot;, example = &quot;系统管理员&quot;, hidden = true) private Long createBy; @TableField(value = &quot;create_time&quot;, fill = FieldFill.INSERT) @ApiModelProperty(value = &quot;创建时间&quot;, hidden = true) @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;) private Date createTime; @ApiModelProperty(value = &quot;更新者&quot;, example = &quot;系统管理员&quot;, hidden = true) private Long updateBy; @TableField(value = &quot;update_time&quot;, fill = FieldFill.INSERT_UPDATE) @ApiModelProperty(value = &quot;更新时间&quot;, hidden = true) private Date updateTime;&#125; 创建VO-DO对象映射接口123456789101112import org.mapstruct.Mapper;@Mapper(componentModel = &quot;spring&quot;)public interface UserMapping &#123; /** * VO对象转DO对象 * @param requestUser * @return */ User toUser(RequestUser requestUser);&#125; 编译后自动生成映射接口的实现类1234567891011121314151617181920212223242526272829303132@Generated( value = &quot;org.mapstruct.ap.MappingProcessor&quot;, date = &quot;2020-12-20T19:29:30+0800&quot;, comments = &quot;version: 1.2.0.CR1, compiler: javac, environment: Java 1.8.0_201 (Oracle Corporation)&quot;)@Componentpublic class UserMappingImpl implements UserMapping &#123; @Override public User toUser(RequestUser requestUser) &#123; if ( requestUser == null ) &#123; return null; &#125; User user = new User(); user.setUserId( requestUser.getUserId() ); user.setUsername( requestUser.getUsername() ); user.setPassword( requestUser.getPassword() ); user.setName( requestUser.getName() ); user.setUserDesc( requestUser.getUserDesc() ); user.setEmployeeNo( requestUser.getEmployeeNo() ); user.setEmail( requestUser.getEmail() ); user.setIsDeleted( requestUser.getIsDeleted() ); user.setCreateBy( requestUser.getCreateBy() ); user.setCreateTime( requestUser.getCreateTime() ); user.setUpdateBy( requestUser.getUpdateBy() ); user.setUpdateTime( requestUser.getUpdateTime() ); return user; &#125;&#125;","categories":[{"name":"技巧","slug":"技巧","permalink":"http://wajj.xin/categories/%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"vo","slug":"vo","permalink":"http://wajj.xin/tags/vo/"},{"name":"do","slug":"do","permalink":"http://wajj.xin/tags/do/"},{"name":"技巧","slug":"技巧","permalink":"http://wajj.xin/tags/%E6%8A%80%E5%B7%A7/"}]},{"title":"JRebel","slug":"技巧/JRebel/JRebel","date":"2021-05-07T06:55:44.000Z","updated":"2021-05-07T07:14:58.847Z","comments":true,"path":"2021/05/07/技巧/JRebel/JRebel/","link":"","permalink":"http://wajj.xin/2021/05/07/%E6%8A%80%E5%B7%A7/JRebel/JRebel/","excerpt":"","text":"https://blog.csdn.net/lianghecai52171314/article/details/105637251 JRebel1. 下载 安装 idea插件中搜索 JRebel and XRebel for IntelliJ 直接下载 https://plugins.jetbrains.com/plugin/4441-jrebel-and-xrebel-for-intellij 安装后重启idea 2. 配置设置面板,找到对应选项 JRebel and XRebel 配置激活码​ 1. https://jrebel.qekang.com/{GUID} ​ GUID 通过 https://www.guidgen.com/ 生成 ​ 2. 随便填邮箱 离线工作模式点击 work offine 设置自动编译 设置中配置 设置compiler.automake.allow.when.app.running 快捷键ctrl+shift+A，搜索：registry或者按快捷键 Ctrl+Shift+Alt+/ ，选择 Registry 使用运行项目时要点击图中红框中的按钮，即可运行：第一个按钮是Run，第二个按钮是Debug。 修改代码（只测试了Java代码的修改）后，按快捷键 Ctrl + Shift + F9，运行后会提示有变化是否重新加载，选yes。完成加载以后，就已经实现了热更新效果。","categories":[{"name":"技巧","slug":"技巧","permalink":"http://wajj.xin/categories/%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"http://wajj.xin/tags/%E6%8A%80%E5%B7%A7/"},{"name":"JRebel","slug":"JRebel","permalink":"http://wajj.xin/tags/JRebel/"}]},{"title":"Gradle","slug":"java/Gradle/Gradle","date":"2021-05-06T07:21:36.000Z","updated":"2021-05-12T03:18:06.415Z","comments":true,"path":"2021/05/06/java/Gradle/Gradle/","link":"","permalink":"http://wajj.xin/2021/05/06/java/Gradle/Gradle/","excerpt":"","text":"Gradle下载 Gralde 官方网站下载 Gradle 的最新发行包 解压 设置环境变量 新建 GRADLE_HOME 值为 解压路径 path 中添加 %GRADLE_HOME%\\bin gradle -version 验证 构建基础Projects 和 tasks 任何一个 Gradle 构建都是由一个或多个 projects 组成 每个 project 包括许多可构建组成部分,每个 project 或许是一个 jar 包或者一个 web 应用，它也可以是一个由许多其他项目中产生的 jar 构成的 zip 压缩包。 每个 project 都由多个 tasks 组成。每个 task 都代表了构建执行过程中的一个原子性操作。如编译，打包，生成 javadoc，发布到某个仓库等操作。 Hello world你可以通过在命令行运行 gradle 命令来执行构建，gradle 命令会从当前目录下寻找 build.gradle 文件来执行构建。我们称 build.gradle 文件为构建脚本。严格来说这其实是一个构建配置脚本，后面你会了解到这个构建脚本定义了一个 project 和一些默认的 task。 build.gradle 12345task hello &#123; doLast &#123; println &#39;Hello world!&#39; &#125;&#125; 然后在该文件所在目录执行 gradle -q hello -q 参数的作用是什么? 该文档的示例中很多地方在调用 gradle 命令时都加了 -q 参数。该参数用来控制 gradle 的日志级别，可以保证只输出我们需要的内容。具体可参阅本文档第十八章日志来了解更多参数和信息。 执行脚本123Output of gradle -q hello&gt; gradle -q helloHello world! 上面的脚本定义了一个叫做 hello 的 task，并且给它添加了一个动作。当执行 gradle hello 的时候, Gralde 便会去调用 hello 这个任务来执行给定操作。这些操作其实就是一个用 groovy 书写的闭包。 如果你觉得它看上去跟 Ant 中的 targets 很像，那么是对的。Gradle 的 tasks 就相当于 Ant 中的 targets。不过你会发现他功能更加强大。我们只是换了一个比 target 更形象的另外一个术语。不幸的是这恰巧与 Ant 中的术语有些冲突。ant 命令中有诸如 javac、copy、tasks。所以当该文档中提及 tasks 时，除非特别指明 ant task。否则指的均是指 Gradle 中的 tasks。 创建项目idea创建项目后会生成build.gradle和settings.gradle两个文件 build.gradlesettings.gradlesettings.gradle是用来管理多项目的，里面包含了项目的name 依赖配置compile（implementation，api）这种是我们最常用的方式，使用该方式依赖的库将会参与编译和打包。 implementation：该依赖方式所依赖的库不会传递，只会在当前module中生效。A-&gt;B B-&gt;C A -x- Capi：该依赖方式会传递所依赖的库，当其他module依赖了该module时，可以使用该module下使用api依赖的库。 A-&gt;B B-&gt;C A -&gt; C provided（compileOnly）只在编译时有效，不会参与打包可以在自己的moudle中使用该方式依赖一些比如com.android.support，gson这些使用者常用的库，避免冲突。 apk（runtimeOnly）只在生成apk的时候参与打包，编译时不会参与，很少用。 testCompile（testImplementation）testCompile 只在单元测试代码的编译以及最终打包测试apk时有效。 debugCompile（debugImplementation）debugCompile 只在debug模式的编译和最终的debug apk打包时有效 releaseCompile（releaseImplementation）Release compile 仅仅针对Release 模式的编译和最终的Release apk打包。 spring boot的gradle配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// buildscript 代码块中脚本优先执行buildscript &#123; // ext 用于定义动态属性 ext &#123; springBootVersion = &#x27;1.5.2.RELEASE&#x27; &#125; // 自定义 Thymeleaf 和 Thymeleaf Layout Dialect 的版本 ext[&#x27;thymeleaf.version&#x27;] = &#x27;3.0.3.RELEASE&#x27; ext[&#x27;thymeleaf-layout-dialect.version&#x27;] = &#x27;2.2.0&#x27; // 自定义 Hibernate 的版本 ext[&#x27;hibernate.version&#x27;] = &#x27;5.2.8.Final&#x27; // 使用了 Maven 的中央仓库（你也可以指定其他仓库） repositories &#123; //mavenCentral() maven &#123; url &#x27;http://maven.aliyun.com/nexus/content/groups/public/&#x27; &#125; &#125; // 依赖关系 dependencies &#123; // classpath 声明说明了在执行其余的脚本时，ClassLoader 可以使用这些依赖项 classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;&quot;) &#125;&#125;// 使用插件apply plugin: &#x27;java&#x27;apply plugin: &#x27;eclipse&#x27;apply plugin: &#x27;org.springframework.boot&#x27;// 打包的类型为 jar，并指定了生成的打包的文件名称和版本jar &#123; baseName = &#x27;springboot-test&#x27; version = &#x27;1.0.0&#x27;&#125;// 指定编译 .java 文件的 JDK 版本sourceCompatibility = 1.8// 默认使用了 Maven 的中央仓库。这里改用自定义的镜像库repositories &#123; //mavenCentral() maven &#123; url &#x27;http://maven.aliyun.com/nexus/content/groups/public/&#x27; &#125;&#125;// 依赖关系dependencies &#123; // 该依赖对于编译发行是必须的 compile(&#x27;org.springframework.boot:spring-boot-starter-web&#x27;) // 添加 Thymeleaf 的依赖 compile(&#x27;org.springframework.boot:spring-boot-starter-thymeleaf&#x27;) // 添加 Spring Security 依赖 compile(&#x27;org.springframework.boot:spring-boot-starter-security&#x27;) // 添加 Spring Boot 开发工具依赖 //compile(&quot;org.springframework.boot:spring-boot-devtools&quot;) // 添加 Spring Data JPA 的依赖 compile(&#x27;org.springframework.boot:spring-boot-starter-data-jpa&#x27;) // 添加 MySQL连接驱动 的依赖 compile(&#x27;mysql:mysql-connector-java:6.0.5&#x27;) // 添加 Thymeleaf Spring Security 依赖，与 Thymeleaf 版本一致都是 3.x compile(&#x27;org.thymeleaf.extras:thymeleaf-extras-springsecurity4:3.0.2.RELEASE&#x27;) // 添加 Apache Commons Lang 依赖 compile(&#x27;org.apache.commons:commons-lang3:3.5&#x27;) // 该依赖对于编译测试是必须的，默认包含编译产品依赖和编译时依 testCompile(&#x27;org.springframework.boot:spring-boot-starter-test&#x27;)&#125;","categories":[{"name":"Gradle","slug":"Gradle","permalink":"http://wajj.xin/categories/Gradle/"}],"tags":[{"name":"Gradle","slug":"Gradle","permalink":"http://wajj.xin/tags/Gradle/"}]},{"title":"Quartz","slug":"java/Quartz/Quartz","date":"2021-04-19T07:24:46.000Z","updated":"2021-04-21T03:19:38.453Z","comments":true,"path":"2021/04/19/java/Quartz/Quartz/","link":"","permalink":"http://wajj.xin/2021/04/19/java/Quartz/Quartz/","excerpt":"","text":"(乱七八糟的复制) Quartz简介Quartz是OpenSymphony开源组织在Job scheduling领域又一个开源项目，是完全由java开发的一个开源的任务日程管理系统，“任务进度管理器”就是一个在预先确定（被纳入日程）的时间到达时，负责执行（或者通知）其他软件组件的系统。这些功能的主要接口(API)是Scheduler接口。它提供了简单的操作，例如：将任务纳入日程或者从日程中取消，开始/停止/暂停日程进度。 定时器种类Quartz 中五种类型的 Trigger：SimpleTrigger，CronTirgger，DateIntervalTrigger，NthIncludedDayTrigger和Calendar 类。最常用的：SimpleTrigger：用来触发只需执行一次或者在给定时间触发并且重复N次且每次执行延迟一定时间的任务CronTrigger：按照cron表达式触发calendars 方式：可以和cron配合使用，用cron表达式指定一个触发时间规律，用calendar指定一个范围 存储方式 类型 优点 缺点 RAMJobStore本地运行 不要外部数据库，配置容易，运行速度快 因为调度程序信息是存储在被分配给JVM的内存里面，所以，当应用程序停止运行时，所有调度信息将被丢失。另外因为存储到JVM内存里面，所以可以存储多少个Job和Trigger将会受到限制 JDBCJobStore使用数据库 支持集群，因为所有的任务信息都会保存到数据库中，可以控制事物，还有就是如果应用服务器关闭或者重启，任务信息都不会丢失，并且可以恢复因服务器关闭或者重启而导致执行失败的任务 运行速度的快慢取决与连接数据库的快慢 表关系 表名 存放数据 qrtz_blob_triggers 以Blob 类型存储的触发器 qrtz_calendars 存放日历信息，quartz可配置一个日历来指定一个时间范围 qrtz_cron_triggers 存放cron类型的触发器 qrtz_fired_triggers 存放已触发的触发器 qrtz_job_details 存放一个jobDetail信息 qrtz_job_listeners job监听器 qrtz_locks 存储程序的悲观锁的信息(假如使用了悲观锁) qrtz_paused_trigger_graps 存放暂停掉的触发器 qrtz_scheduler_state 调度器状态 qrtz_simple_triggers 简单触发器的信息 qrtz_trigger_listeners 触发器监听器 qrtz_triggers 触发器的基本信息 cron方式需要用到的4张数据表： 1qrtz_triggers，qrtz_cron_triggers，qrtz_fired_triggers，qrtz_job_details 字段详解qrtz_blob_triggers自定义触发器表 123456789CREATE TABLE `qrtz_blob_triggers` ( `SCHED_NAME` varchar(120) NOT NULL COMMENT &#x27;计划名称&#x27;, `TRIGGER_NAME` varchar(200) NOT NULL COMMENT &#x27;触发器名称&#x27;, `TRIGGER_GROUP` varchar(200) NOT NULL COMMENT &#x27;触发器群组&#x27;, `BLOB_DATA` blob COMMENT &#x27;基本信息&#x27;, PRIMARY KEY (`SCHED_NAME`,`TRIGGER_NAME`,`TRIGGER_GROUP`), KEY `SCHED_NAME` (`SCHED_NAME`,`TRIGGER_NAME`,`TRIGGER_GROUP`), CONSTRAINT `qrtz_blob_triggers_ibfk_1` FOREIGN KEY (`SCHED_NAME`, `TRIGGER_NAME`, `TRIGGER_GROUP`) REFERENCES `qrtz_triggers` (`SCHED_NAME`, `TRIGGER_NAME`, `TRIGGER_GROUP`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;用于 Quartz 用户用 JDBC 创建他们自己定制的 Trigger 类型，JobStore并不知道如何存储实例的时候&#x27;; qrtz_calendars日历信息触发器 123456CREATE TABLE `qrtz_calendars` ( `SCHED_NAME` varchar(120) NOT NULL COMMENT &#x27;计划名称&#x27;, `CALENDAR_NAME` varchar(200) NOT NULL COMMENT &#x27;触发器名称&#x27;, `CALENDAR` blob NOT NULL COMMENT &#x27;日历信息&#x27;, PRIMARY KEY (`SCHED_NAME`,`CALENDAR_NAME`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;日历信息触发器&#x27;; qrtz_cron_triggerscron 表达式触发器 123456789CREATE TABLE `qrtz_cron_triggers` ( `SCHED_NAME` varchar(120) NOT NULL COMMENT &#x27;计划名称&#x27;, `TRIGGER_NAME` varchar(200) NOT NULL COMMENT &#x27;触发器名称&#x27;, `TRIGGER_GROUP` varchar(200) NOT NULL COMMENT &#x27;触发器群组&#x27;, `CRON_EXPRESSION` varchar(120) NOT NULL COMMENT &#x27;cron表达式&#x27;, `TIME_ZONE_ID` varchar(80) DEFAULT NULL COMMENT &#x27;时区&#x27;, PRIMARY KEY (`SCHED_NAME`,`TRIGGER_NAME`,`TRIGGER_GROUP`), CONSTRAINT `qrtz_cron_triggers_ibfk_1` FOREIGN KEY (`SCHED_NAME`, `TRIGGER_NAME`, `TRIGGER_GROUP`) REFERENCES `qrtz_triggers` (`SCHED_NAME`, `TRIGGER_NAME`, `TRIGGER_GROUP`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;cron触发器&#x27;; qrtz_fired_triggers已触发的触发器 12345678910111213141516171819202122CREATE TABLE `qrtz_fired_triggers` ( `SCHED_NAME` varchar(120) NOT NULL COMMENT &#x27;计划名称&#x27;, `ENTRY_ID` varchar(95) NOT NULL COMMENT &#x27;组织id&#x27;, `TRIGGER_NAME` varchar(200) NOT NULL COMMENT &#x27;触发器名称&#x27;, `TRIGGER_GROUP` varchar(200) NOT NULL COMMENT &#x27;触发器组&#x27;, `INSTANCE_NAME` varchar(200) NOT NULL COMMENT &#x27;实例名称&#x27;, `FIRED_TIME` bigint(13) NOT NULL COMMENT &#x27;触发时间&#x27;, `SCHED_TIME` bigint(13) NOT NULL COMMENT &#x27;计划时间&#x27;, `PRIORITY` int(11) NOT NULL COMMENT &#x27;权重&#x27;, `STATE` varchar(16) NOT NULL COMMENT &#x27;状态&#x27;, `JOB_NAME` varchar(200) DEFAULT NULL COMMENT &#x27;作业名称&#x27;, `JOB_GROUP` varchar(200) DEFAULT NULL COMMENT &#x27;作业群组&#x27;, `IS_NONCONCURRENT` varchar(1) DEFAULT NULL COMMENT &#x27;是否并行&#x27;, `REQUESTS_RECOVERY` varchar(1) DEFAULT NULL COMMENT &#x27;是否要求唤醒&#x27;, PRIMARY KEY (`SCHED_NAME`,`ENTRY_ID`), KEY `IDX_QRTZ_FT_TRIG_INST_NAME` (`SCHED_NAME`,`INSTANCE_NAME`), KEY `IDX_QRTZ_FT_INST_JOB_REQ_RCVRY` (`SCHED_NAME`,`INSTANCE_NAME`,`REQUESTS_RECOVERY`), KEY `IDX_QRTZ_FT_J_G` (`SCHED_NAME`,`JOB_NAME`,`JOB_GROUP`), KEY `IDX_QRTZ_FT_JG` (`SCHED_NAME`,`JOB_GROUP`), KEY `IDX_QRTZ_FT_T_G` (`SCHED_NAME`,`TRIGGER_NAME`,`TRIGGER_GROUP`), KEY `IDX_QRTZ_FT_TG` (`SCHED_NAME`,`TRIGGER_GROUP`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;存储与已触发的 Trigger 相关的状态信息，以及相联 Job的执行信息QRTZ_PAUSED_TRIGGER_GRPS 存储已暂停的 Trigger组的信息&#x27;; qrtz_job_details123456789101112131415CREATE TABLE `qrtz_job_details` ( `SCHED_NAME` varchar(120) NOT NULL COMMENT &#x27;调度器名称&#x27;, `JOB_NAME` varchar(200) NOT NULL COMMENT &#x27;任务名称&#x27;, `JOB_GROUP` varchar(200) NOT NULL COMMENT &#x27;任务群组&#x27;, `DESCRIPTION` varchar(250) DEFAULT NULL COMMENT &#x27;说明&#x27;, `JOB_CLASS_NAME` varchar(250) NOT NULL COMMENT &#x27;任务class全路径&#x27;, `IS_DURABLE` varchar(1) NOT NULL COMMENT &#x27;是否持久化,值为1会把job持久化到数据库中&#x27;, `IS_NONCONCURRENT` varchar(1) NOT NULL COMMENT &#x27;是否并行&#x27;, `IS_UPDATE_DATA` varchar(1) NOT NULL, `REQUESTS_RECOVERY` varchar(1) NOT NULL COMMENT &#x27;是否要求唤醒&#x27;, `JOB_DATA` blob, PRIMARY KEY (`SCHED_NAME`,`JOB_NAME`,`JOB_GROUP`), KEY `IDX_QRTZ_J_REQ_RECOVERY` (`SCHED_NAME`,`REQUESTS_RECOVERY`), KEY `IDX_QRTZ_J_GRP` (`SCHED_NAME`,`JOB_GROUP`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; qrtz_locks在集群模式下，通过悲观锁来保证触发器有序的获取。 12345CREATE TABLE `qrtz_locks` ( `SCHED_NAME` varchar(120) NOT NULL COMMENT &#x27;计划名称&#x27;, `LOCK_NAME` varchar(40) NOT NULL COMMENT &#x27;锁名称&#x27;, PRIMARY KEY (`SCHED_NAME`,`LOCK_NAME`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;通过悲观锁获取触发器&#x27;; qrtz_paused_trigger_grps12345CREATE TABLE `qrtz_paused_trigger_grps` ( `SCHED_NAME` varchar(120) NOT NULL COMMENT &#x27;计划名称&#x27;, `TRIGGER_GROUP` varchar(200) NOT NULL COMMENT &#x27;触发器组&#x27;, PRIMARY KEY (`SCHED_NAME`,`TRIGGER_GROUP`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;被暂停的触发器&#x27;; qrtz_scheduler_state1234567CREATE TABLE `qrtz_scheduler_state` ( `SCHED_NAME` varchar(120) NOT NULL COMMENT &#x27;调度器名称&#x27;, `INSTANCE_NAME` varchar(200) NOT NULL, `LAST_CHECKIN_TIME` bigint(13) NOT NULL COMMENT &#x27;最后验证时间&#x27;, `CHECKIN_INTERVAL` bigint(13) NOT NULL COMMENT &#x27;时间间隔&#x27;, PRIMARY KEY (`SCHED_NAME`,`INSTANCE_NAME`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; qrtz_simple_triggers12345678910CREATE TABLE `qrtz_simple_triggers` ( `SCHED_NAME` varchar(120) NOT NULL COMMENT &#x27;计划名称&#x27;, `TRIGGER_NAME` varchar(200) NOT NULL COMMENT &#x27;触发器名称&#x27;, `TRIGGER_GROUP` varchar(200) NOT NULL COMMENT &#x27;触发器组&#x27;, `REPEAT_COUNT` bigint(7) NOT NULL COMMENT &#x27;重复次数&#x27;, `REPEAT_INTERVAL` bigint(12) NOT NULL COMMENT &#x27;重复间隔&#x27;, `TIMES_TRIGGERED` bigint(10) NOT NULL COMMENT &#x27;触发次数&#x27;, PRIMARY KEY (`SCHED_NAME`,`TRIGGER_NAME`,`TRIGGER_GROUP`), CONSTRAINT `qrtz_simple_triggers_ibfk_1` FOREIGN KEY (`SCHED_NAME`, `TRIGGER_NAME`, `TRIGGER_GROUP`) REFERENCES `qrtz_triggers` (`SCHED_NAME`, `TRIGGER_NAME`, `TRIGGER_GROUP`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;存储简单的Trigger，包括重复次数，间隔，以及已触的次数&#x27;; qrtz_triggers1234567891011121314151617181920212223242526272829303132CREATE TABLE `qrtz_triggers` ( `SCHED_NAME` varchar(120) NOT NULL COMMENT &#x27;计划名称&#x27;, `TRIGGER_NAME` varchar(200) NOT NULL COMMENT &#x27;触发器名称&#x27;, `TRIGGER_GROUP` varchar(200) NOT NULL COMMENT &#x27;触发器群组&#x27;, `JOB_NAME` varchar(200) NOT NULL COMMENT &#x27;作业名称&#x27;, `JOB_GROUP` varchar(200) NOT NULL COMMENT &#x27;作业群组&#x27;, `DESCRIPTION` varchar(250) DEFAULT NULL COMMENT &#x27;说明信息&#x27;, `NEXT_FIRE_TIME` bigint(13) DEFAULT NULL COMMENT &#x27;下次执行时间&#x27;, `PREV_FIRE_TIME` bigint(13) DEFAULT NULL COMMENT &#x27;上次执行时间&#x27;, `PRIORITY` int(11) DEFAULT NULL COMMENT &#x27;线程优先级&#x27;, `TRIGGER_STATE` varchar(16) NOT NULL COMMENT &#x27;触发状态此字段很重要&#x27;, `TRIGGER_TYPE` varchar(8) NOT NULL COMMENT &#x27;触发器类型&#x27;, `START_TIME` bigint(13) NOT NULL COMMENT &#x27;开始时间&#x27;, `END_TIME` bigint(13) DEFAULT NULL COMMENT &#x27;结束时间&#x27;, `CALENDAR_NAME` varchar(200) DEFAULT NULL COMMENT &#x27;日历名称&#x27;, `MISFIRE_INSTR` smallint(2) DEFAULT NULL, `JOB_DATA` blob, PRIMARY KEY (`SCHED_NAME`,`TRIGGER_NAME`,`TRIGGER_GROUP`), KEY `IDX_QRTZ_T_J` (`SCHED_NAME`,`JOB_NAME`,`JOB_GROUP`), KEY `IDX_QRTZ_T_JG` (`SCHED_NAME`,`JOB_GROUP`), KEY `IDX_QRTZ_T_C` (`SCHED_NAME`,`CALENDAR_NAME`), KEY `IDX_QRTZ_T_G` (`SCHED_NAME`,`TRIGGER_GROUP`), KEY `IDX_QRTZ_T_STATE` (`SCHED_NAME`,`TRIGGER_STATE`), KEY `IDX_QRTZ_T_N_STATE` (`SCHED_NAME`,`TRIGGER_NAME`,`TRIGGER_GROUP`,`TRIGGER_STATE`), KEY `IDX_QRTZ_T_N_G_STATE` (`SCHED_NAME`,`TRIGGER_GROUP`,`TRIGGER_STATE`), KEY `IDX_QRTZ_T_NEXT_FIRE_TIME` (`SCHED_NAME`,`NEXT_FIRE_TIME`), KEY `IDX_QRTZ_T_NFT_ST` (`SCHED_NAME`,`TRIGGER_STATE`,`NEXT_FIRE_TIME`), KEY `IDX_QRTZ_T_NFT_MISFIRE` (`SCHED_NAME`,`MISFIRE_INSTR`,`NEXT_FIRE_TIME`), KEY `IDX_QRTZ_T_NFT_ST_MISFIRE` (`SCHED_NAME`,`MISFIRE_INSTR`,`NEXT_FIRE_TIME`,`TRIGGER_STATE`), KEY `IDX_QRTZ_T_NFT_ST_MISFIRE_GRP` (`SCHED_NAME`,`MISFIRE_INSTR`,`NEXT_FIRE_TIME`,`TRIGGER_GROUP`,`TRIGGER_STATE`), CONSTRAINT `qrtz_triggers_ibfk_1` FOREIGN KEY (`SCHED_NAME`, `JOB_NAME`, `JOB_GROUP`) REFERENCES `qrtz_job_details` (`SCHED_NAME`, `JOB_NAME`, `JOB_GROUP`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;触发器和作业绑定&#x27;; quartz体系结构Quartz APIQuartz API的关键接口是： Scheduler - 与调度程序交互的主要API。可以注册Trigger和JobDetails到Scheduler中,当Trigger触发时，对应的Job就被执行 Job - 你想要调度器执行的任务组件需要实现的接口 JobDetail - 用于定义作业的实例。 Trigger（即触发器） - 定义执行给定作业的计划的触发条件。 JobBuilder - 用于定义/构建 JobDetail 实例，用于定义作业的实例。 TriggerBuilder - 用于定义/构建触发器实例。 Scheduler 的生命期，从 SchedulerFactory 创建它时开始，到 Scheduler 调用shutdown() 方法时结束；Scheduler 被创建后，可以增加、删除和列举 Job 和 Trigger，以及执行其它与调度相关的操作（如暂停 Trigger）。但是，Scheduler 只有在调用 start() 方法后，才会真正地触发 trigger（即执行 job） Job一个 job 就是一个实现了 Job 接口的类，该接口只有一个方法： 1234567package org.quartz;public interface Job &#123; public void execute(JobExecutionContext context) throws JobExecutionException;&#125; job的一个 trigger 被触发后，execute() 方法会被 scheduler 的一个工作线程调用；传递给 execute() 方法的 JobExecutionContext 对象中保存着该 job 运行时的一些信息 ，执行 job 的 scheduler 的引用，触发 job 的 trigger 的引用，JobDetail 对象引用，以及一些其它信息。 注解 @DisallowConcurrentExecution：将该注解加到job类上，告诉Quartz不要并发地执行同一个job定义（这里指特定的job类）的多个实例。 @PersistJobDataAfterExecution：将该注解加在job类上，告诉Quartz在成功执行了job类的execute方法后（没有发生任何异常），更新JobDetail中JobDataMap的数据，使得该job（即JobDetail）在下一次执行的时候，JobDataMap中是更新后的数据，而不是更新前的旧数据。 属性 Durability：如果一个job是非持久的，当没有活跃的trigger与之关联的时候，会被自动地从scheduler中删除。也就是说，非持久的job的生命期是由trigger的存在与否决定的； RequestsRecovery：如果一个job是可恢复的，并且在其执行的时候，scheduler发生硬关闭（hard shutdown)（比如运行的进程崩溃了，或者关机了），则当scheduler重新启动的时候，该job会被重新执行。此时，该job的JobExecutionContext.isRecovering() 返回true。 TriggerTrigger 用于触发 Job 的执行。当你准备调度一个 job 时，你创建一个 Trigger 的实例，然后设置调度相关的属性。Trigger 也有一个相关联的 JobDataMap，用于给 Job 传递一些触发相关的参数。Quartz 自带了各种不同类型的 Trigger，最常用的主要是 SimpleTrigger 和 CronTrigger。 一个Job可以对应多个Trigger，但一个Trigger只能对应一个Job。 当一个trigger被触发时，与之关联的JobDetail实例会被加载，JobDetail引用的job类通过配置在Scheduler上的JobFactory进行初始化。默认的JobFactory实现，仅仅是调用job类的newInstance()方法，然后尝试调用JobDataMap中的key的setter方法。 TRIGGER_STATE的值WAITING:等待 PAUSED:暂停 ACQUIRED:正常执行 BLOCKED：阻塞 ERROR：错误 错过触发MISFIRE_INSTR MisFire策略常量的定义在类CronTrigger中，列举如下： 常量值 含义 withMisfireHandlingInstructionDoNothing 不触发立即执行,等待下次Cron触发频率到达时刻开始按照Cron频率依次执行 withMisfireHandlingInstructionIgnoreMisfires 以错过的第一个频率时间立刻开始执行,重做错过的所有频率周期后,当下一次触发频率发生时间大于当前时间后，再按照正常的Cron频率依次执行 withMisfireHandlingInstructionFireAndProceed 以当前时间为触发频率立刻触发一次执行,然后按照Cron频率依次执行 公共属性 TriggerKey属性：表示trigger的身份 jobKey属性：当trigger触发时被执行的job的身份； startTime属性：设置trigger第一次触发的时间；该属性的值是java.util.Date类型，表示某个指定的时间点；有些类型的trigger，会在设置的startTime时立即触发，有些类型的trigger，表示其触发是在startTime之后开始生效。比如，现在是1月份，你设置了一个trigger–“在每个月的第5天执行”，然后你将startTime属性设置为4月1号，则该trigger第一次触发会是在几个月以后了(即4月5号)。 endTime属性：表示trigger失效的时间点。比如，”每月第5天执行”的trigger，如果其endTime是7月1号，则其最后一次执行时间是6月5号。 优先级 如果Quartz可能没有足够的资源同时触发所有的trigger,可以设置哪个trigger优先使用Quartz的工作线程，设置priority属性。比如，你有N个trigger需要同时触发，但只有Z个工作线程，优先级最高的Z个trigger会被首先触发。如果没有为trigger设置优先级，trigger使用默认优先级，值为5；priority属性的值可以是任意整数，正数、负数都可以。 注意：只有同时触发的trigger之间才会比较优先级。10:59触发的trigger总是在11:00触发的trigger之前执行。 注意：如果trigger是可恢复的，在恢复后再调度时，优先级与原trigger是一样的。 错过触发(misfire Instructions) trigger还有一个重要的属性misfire；如果scheduler关闭了，或者Quartz线程池中没有可用的线程来执行job，此时持久性的trigger就会错过(miss)其触发时间，即错过触发(misfire)。不同类型的trigger，有不同的misfire机制。它们默认都使用“智能机制(smart policy)”，即根据trigger的类型和配置动态调整行为。当scheduler启动的时候，查询所有错过触发(misfire)的持久性trigger。然后根据它们各自的misfire机制更新trigger的信息。 日历 Quartz的Calendar对象(不是java.util.Calendar对象)可以在定义和存储trigger的时候与trigger进行关联。Calendar用于从trigger的调度计划中排除时间段。 key将 Job 和 Trigger 注册到 Scheduler 时，可以为它们设置 key，配置其身份属性。 Job 和 Trigger 的 key（JobKey 和 TriggerKey）可以用于将 Job 和 Trigger 放到不同的分组（group）里，然后基于分组进行操作。同一个分组下的 Job 或 Trigger 的名称必须唯一，即一个 Job 或 Trigger 的 key 由名称（name）和分组（group）组成。 JobDataMapJobDataMap中可以包含不限量的（序列化的）数据对象，在job实例执行的时候，可以使用其中的数据 JobDataMap是Java Map接口的一个实现，额外增加了一些便于存取基本类型的数据的方法。 将job加入到scheduler之前，在构建JobDetail时，可以将数据放入JobDataMap 存 12345JobDetail job = newJob(DumbJob.class) .withIdentity(&quot;myJob&quot;, &quot;group1&quot;) // name &quot;myJob&quot;, group &quot;group1&quot; .usingJobData(&quot;jobSays&quot;, &quot;Hello World!&quot;) .usingJobData(&quot;myFloatValue&quot;, 3.141f) .build(); 取 123456789101112131415161718public class DumbJob implements Job &#123; public DumbJob() &#123; &#125; public void execute(JobExecutionContext context) throws JobExecutionException &#123; JobKey key = context.getJobDetail().getKey(); JobDataMap dataMap = context.getJobDetail().getJobDataMap(); String jobSays = dataMap.getString(&quot;jobSays&quot;); float myFloatValue = dataMap.getFloat(&quot;myFloatValue&quot;); System.err.println(&quot;Instance &quot; + key + &quot; of DumbJob says: &quot; + jobSays + &quot;, and val is: &quot; + myFloatValue); &#125;&#125; TriggerListeners和JobListenersListeners是用于根据调度程序中发生的事件执行操作 与Trigger相关的事件包括：触发器触发，触发失灵，触发完成 与job相关的事件包括：job即将执行的通知，以及job完成执行时的通知 使用Listeners 要创建一个listener，只需创建一个实现org.quartz.TriggerListener和/或org.quartz.JobListener接口的对象。然后，listener在运行时会向调度程序注册，并且必须给出一个名称（或者，他们必须通过他们的getName（）方法来宣传自己的名字）。 为了方便起见，实现这些接口，您的类也可以扩展JobListenerSupport类或TriggerListenerSupport类，并且只需覆盖您感兴趣的事件。 listener与调度程序的ListenerManager一起注册，并配有描述listener希望接收事件的job/触发器的Matcher。 添加对特定job感兴趣的JobListener： 1scheduler.getListenerManager().addJobListener(myJobListener，KeyMatcher.jobKeyEquals(new JobKey(&quot;myJobName&quot;，&quot;myJobGroup&quot;))); 添加对特定组的所有job感兴趣的JobListener： 1scheduler.getListenerManager().addJobListener(myJobListener, jobGroupEquals(&quot;myJobGroup&quot;)); 添加对两个特定组的所有job感兴趣的JobListener： 1scheduler.getListenerManager().addJobListener(myJobListener, or(jobGroupEquals(&quot;myJobGroup&quot;), jobGroupEquals(&quot;yourGroup&quot;))); 添加对所有job感兴趣的JobListener： 1scheduler.getListenerManager().addJobListener(myJobListener, allJobs()); Job StoresRAMJobStore 将所有数据保存在RAM中,速度快但易失 1org.quartz.jobStore.class = org.quartz.simpl.RAMJobStore JDBC JobStore 通过JDBC将其所有数据保存在数据库中 1org.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreTX quartz.properties12345678910111213141516171819202122232425262728293031323334# 调度标识名 集群中每一个实例都必须使用相同的名称 （区分特定的调度器实例）org.quartz.scheduler.instanceName=DefaultQuartzScheduler# ID设置为自动获取 每一个必须不同 （所有调度器实例中是唯一的）org.quartz.scheduler.instanceId=AUTO# 使用内存存储quartz的所有数据，包括job和trigger的配置#org.quartz.jobStore.class = org.quartz.simpl.RAMJobStore# 数据保存方式为持久化org.quartz.jobStore.class=org.quartz.impl.jdbcjobstore.JobStoreTX# 表的前缀org.quartz.jobStore.tablePrefix=QRTZ_# 设置为TRUE不会出现序列化非字符串类到 BLOB 时产生的类版本问题# org.quartz.jobStore.useProperties = true# 加入集群 true 为集群 false不是集群org.quartz.jobStore.isClustered=false# 调度实例失效的检查时间间隔org.quartz.jobStore.clusterCheckinInterval=20000# 容许的最大作业延长时间org.quartz.jobStore.misfireThreshold=60000# ThreadPool 实现的类名org.quartz.threadPool.class=org.quartz.simpl.SimpleThreadPool# 线程池中有10个线程，这意味着最多可以同时运行10个joborg.quartz.threadPool.threadCount=10# 线程优先级org.quartz.threadPool.threadPriority=5（threadPriority 属性的最大值是常量 java.lang.Thread.MAX_PRIORITY，等于10。最小值为常量 java.lang.Thread.MIN_PRIORITY，为1）# 自创建父线程# org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread = true# 数据库别名org.quartz.jobStore.dataSource=qzDS# 设置数据源org.quartz.dataSource.qzDS.driver=com.mysql.jdbc.Driverorg.quartz.dataSource.qzDS.URL=jdbc:mysql://localhost:3306/quartzorg.quartz.dataSource.qzDS.user=rootorg.quartz.dataSource.qzDS.password=123456org.quartz.dataSource.qzDS.maxConnection=10 简单实例依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt;&lt;/dependency&gt; job 12345678public class PrintJob extends QuartzJobBean &#123; @Override protected void executeInternal(final JobExecutionContext context) throws JobExecutionException &#123; System.out.println(&quot;当前时间: &quot; + new Date()); &#125;&#125; Scheduler 12345678910111213141516171819202122232425262728public class MyScheduler &#123; public static void main(String[] args) throws SchedulerException, InterruptedException &#123; // 1、创建调度器Scheduler SchedulerFactory schedulerFactory = new StdSchedulerFactory(); Scheduler scheduler = schedulerFactory.getScheduler(); // 2、创建JobDetail实例，并与PrintWordsJob类绑定(Job执行内容) JobDetail jobDetail = JobBuilder.newJob(PrintJob.class) .withIdentity(&quot;job1&quot;, &quot;group1&quot;).build(); // 3、构建Trigger实例,每隔1s执行一次 Trigger trigger = TriggerBuilder.newTrigger().withIdentity(&quot;trigger1&quot;, &quot;triggerGroup1&quot;) .startNow()//立即生效 .withSchedule(SimpleScheduleBuilder.simpleSchedule() .withIntervalInSeconds(1)//每隔1s执行一次 .repeatForever()).build();//一直执行 //4、绑定schedule和jobDetail scheduler.scheduleJob(jobDetail, trigger); System.out.println(&quot;--------scheduler start ! ------------&quot;); //5、执行 scheduler.start(); //睡眠 TimeUnit.MINUTES.sleep(1); scheduler.shutdown(); System.out.println(&quot;--------scheduler shutdown ! ------------&quot;); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://wajj.xin/categories/java/"},{"name":"Quartz","slug":"java/Quartz","permalink":"http://wajj.xin/categories/java/Quartz/"}],"tags":[{"name":"java","slug":"java","permalink":"http://wajj.xin/tags/java/"},{"name":"Quartz","slug":"Quartz","permalink":"http://wajj.xin/tags/Quartz/"}]},{"title":"nginx","slug":"Linux/nginx/nginx","date":"2021-04-16T13:21:10.000Z","updated":"2021-05-08T07:39:28.365Z","comments":true,"path":"2021/04/16/Linux/nginx/nginx/","link":"","permalink":"http://wajj.xin/2021/04/16/Linux/nginx/nginx/","excerpt":"","text":"nginx高性能的HTTP和反向代理服务器,也提供IMAP/POP3/SMTP服务 特点: ​ 内存占用少 ​ 并发强(5w) ​ 能够热部署 配置文件nginx配置文件中分为三部分:全局块,events块,http块 nginx.conf 结构图可以这样概括： 12345678910main # 全局配置，对全局生效├── events # 配置影响 Nginx 服务器或与用户的网络连接├── http # 配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置│ ├── upstream # 配置后端服务器具体地址，负载均衡配置不可或缺的部分│ ├── server # 配置虚拟主机的相关参数，一个 http 块中可以有多个 server 块│ ├── server│ │ ├── location # server 块可以包含多个 location 块，location 指令用于匹配 uri│ │ ├── location│ │ └── ...│ └── ... 语法 配置文件由指令与指令块构成； 每条指令以 ; 分号结尾，指令与参数间以空格符号分隔； 指令块以 &#123;&#125; 大括号将多条指令组织在一起； include 语句允许组合多个配置文件以提升可维护性； 使用 # 符号添加注释，提高可读性； 使用 $ 符号使用变量； 部分指令的参数支持正则表达式； server 块可以包含多个 location 块，location 指令用于匹配 uri，语法： 123location [ &#x3D; | ~ | ~* | ^~] uri &#123; ...&#125; 指令后面： = 精确匹配路径，用于不含正则表达式的 uri 前，如果匹配成功，不再进行后续的查找； ^~ 用于不含正则表达式的 uri； 前，表示如果该符号后面的字符是最佳匹配，采用该规则，不再进行后续的查找； ~ 表示用该符号后面的正则去匹配路径，区分大小写； ~* 表示用该符号后面的正则去匹配路径，不区分大小写。跟 ~ 优先级都比较低，如有多个location的正则能匹配的话，则使用正则表达式最长的那个； 如果 uri 包含正则表达式，则必须要有 ~ 或 ~* 标志。 正反向代理正向代理: 代理客户端,请求通过代理服务器进行互联网访问,隐藏了真实的客户端地址，代理服务器为客户端收发请求，使真实客户端对服务器不可见 代理服务器端,客户端不需要任何配置,将请求发送给反向代理服务器,反向代理服务器会对请求进行分发,在客户端视角不知道有分发的过程,认为反向代理服务器和目标服务器是一个整体 服务器只暴露了反向代理服务器地址,隐藏了真实服务器地址,提高了安全性 配置: 负载均衡 Nginx提供的负载均衡策略有2种：内置策略和扩展策略。 内置策略为轮询，加权轮询，Ip hash。 轮询，默认方式，每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务挂了，能自动剔除； weight，权重分配，指定轮询几率，权重越高，在被访问的概率越大，用于后端服务器性能不均的情况； ip_hash，每个请求按访问 IP 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决动态网页 session 共享问题。负载均衡每次请求都会重新定位到服务器集群中的某一个，那么已经登录某一个服务器的用户再重新定位到另一个服务器，其登录信息将会丢失，这样显然是不妥的； fair（第三方），按后端服务器的响应时间分配，响应时间短的优先分配，依赖第三方插件 nginx-upstream-fair，需要先安装； 动静分离在我们的开发中，有些请求是需要后台处理的，有些请求是不需要经过后台处理的（如：css、html、jpg、js等等文件），这些不需要经过后台处理的文件称为静态文件。 让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作。提高资源响应的速度。 方式 纯粹把静态文件独立成单独的域名，放在独立的服务器上(主流) 动态跟静态文件混合在一起发布， 通过 Nginx 配置来分开 建议搭配缓存使用 通过 expires 参数设置，可以使浏览器缓存过期时间，减少与服务器之前的请求和流量。 具体 expires 定义：是给一个资源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，所以不会产生额外的流量。此种方法非常适合不经常变动的资源。 设置为3d，表示在这 3 天之内访问这个URL，发送一个请求，比对服务器该文件最后更新时间没有变化。则不会从服务器抓取，返回状态码 304，如果有修改，则直接从服务器重新下载，返回状态码 200。 GZip使用 gzip 不仅需要 Nginx 配置，浏览器端也需要配合，需要在请求消息头中包含 Accept-Encoding: gzip（IE5 之后所有的浏览器都支持了，是现代浏览器的默认设置）。一般在请求 html 和 css 等静态资源的时候，支持的浏览器在 request 请求静态资源的时候，会加上 Accept-Encoding: gzip 这个 header，表示自己支持 gzip 的压缩方式，Nginx 在拿到这个请求的时候，如果有相应配置，就会返回经过 gzip 压缩过的文件给浏览器，并在 response 相应的时候加上 content-encoding: gzip 来告诉浏览器自己采用的压缩方式（因为浏览器在传给服务器的时候一般还告诉服务器自己支持好几种压缩方式），浏览器拿到压缩的文件后，根据自己的解压方式进行解析。 12345678910111213# &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;gzip.confgzip on; # 默认off，是否开启gzipgzip_types text&#x2F;plain text&#x2F;css application&#x2F;json application&#x2F;x-javascript text&#x2F;xml application&#x2F;xml application&#x2F;xml+rss text&#x2F;javascript;# 上面两个开启基本就能跑起了，下面的愿意折腾就了解一下gzip_static on;gzip_proxied any;gzip_vary on;gzip_comp_level 6;gzip_buffers 16 8k;# gzip_min_length 1k;gzip_http_version 1.1; 稍微解释一下： gzip_types：要采用 gzip 压缩的 MIME 文件类型，其中 text/html 被系统强制启用； gzip_static：默认 off，该模块启用后，Nginx 首先检查是否存在请求静态文件的 gz 结尾的文件，如果有则直接返回该 .gz 文件内容； gzip_proxied：默认 off，nginx做为反向代理时启用，用于设置启用或禁用从代理服务器上收到相应内容 gzip 压缩； gzip_vary：用于在响应消息头中添加 Vary：Accept-Encoding，使代理服务器根据请求头中的 Accept-Encoding 识别是否启用 gzip 压缩； gzip_comp_level：gzip 压缩比，压缩级别是 1-9，1 压缩级别最低，9 最高，级别越高压缩率越大，压缩时间越长，建议 4-6； gzip_buffers：获取多少内存用于缓存压缩结果，16 8k 表示以 8k*16 为单位获得； gzip_min_length：允许压缩的页面最小字节数，页面字节数从header头中的 Content-Length 中进行获取。默认值是 0，不管页面多大都压缩。建议设置成大于 1k 的字节数，小于 1k 可能会越压越大； gzip_http_version：默认 1.1，启用 gzip 所需的 HTTP 最低版本； 这个配置可以插入到 http 模块整个服务器的配置里，也可以插入到需要使用的虚拟主机的 server 或者下面的 location 模块中，当然像上面我们这样写的话就是被 include 到 http 模块中了。 安装1234#安装apt-get install nginx#启动service nginx start 目录 /usr/sbin/nginx：主程序 /etc/nginx：存放配置文件 /usr/share/nginx：存放静态文件 /var/log/nginx：存放日志 命令12345678# 查看nginx状态nginx -t# 重新载入配置文件nginx -s reload# 重启 Nginxnginx -s reopen# 停止 Nginxnginx -s stop","categories":[{"name":"Linux","slug":"Linux","permalink":"http://wajj.xin/categories/Linux/"},{"name":"nginx","slug":"Linux/nginx","permalink":"http://wajj.xin/categories/Linux/nginx/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://wajj.xin/tags/Linux/"},{"name":"nginx","slug":"nginx","permalink":"http://wajj.xin/tags/nginx/"}]},{"title":"数据库设计","slug":"数据库/数据库设计/数据库设计","date":"2021-04-16T13:21:10.000Z","updated":"2021-05-08T07:41:47.218Z","comments":true,"path":"2021/04/16/数据库/数据库设计/数据库设计/","link":"","permalink":"http://wajj.xin/2021/04/16/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"数据库表设计中，I、M、P、F、U、C分别代表什么C = CHECK 约束D = 默认值或 DEFAULT 约束F = FOREIGN KEY 约束I = IndexL = 日志FN = 标量函数IF = 内嵌表函数P = 存储过程PK = PRIMARY KEY 约束（类型是 K）RF = 复制筛选存储过程S = 系统表TF = 表函数TR = 触发器U = 用户表UQ = UNIQUE 约束（类型是 K）V = 视图X = 扩展存储过程","categories":[{"name":"数据库","slug":"数据库","permalink":"http://wajj.xin/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库设计","slug":"数据库设计","permalink":"http://wajj.xin/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"}]},{"title":"mysql","slug":"数据库/mysql/mysql","date":"2021-04-11T12:51:41.000Z","updated":"2021-04-19T07:20:11.024Z","comments":true,"path":"2021/04/11/数据库/mysql/mysql/","link":"","permalink":"http://wajj.xin/2021/04/11/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql/","excerpt":"","text":"mysql连接数据库1234567891011# mysql 5 驱动 com.mysql.jdbc.Driverspring.datasource.username=rootspring.datasource.password=rootspring.datasource.url=jdbc:mysql://localhost:3306/test?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8spring.datasource.driver-classs-name=com.mysql.jdbc.Driver# mysql 8 驱动 com.mysql.cj.jdbc.Driver 需要增加时区配置spring.datasource.username=rootspring.datasource.password=rootspring.datasource.url=jdbc:mysql://localhost:3306/test?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghaispring.datasource.driver-classs-name=com.mysql.cj.jdbc.Driver useSSL=false 是否使用安全连接 useUnicode=true&amp;charactgerEncoding=UTF-8 使用utf-8的格式存取数据 serverTimezone=Asia/Shanghai 时区设置,还可以为GMT%wb8(GMT+8)","categories":[{"name":"mysql","slug":"mysql","permalink":"http://wajj.xin/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://wajj.xin/tags/mysql/"}]},{"title":"Spring Security","slug":"java/SpringSecurity/SpringSecurity","date":"2021-04-11T12:51:41.000Z","updated":"2021-04-27T13:26:40.186Z","comments":true,"path":"2021/04/11/java/SpringSecurity/SpringSecurity/","link":"","permalink":"http://wajj.xin/2021/04/11/java/SpringSecurity/SpringSecurity/","excerpt":"","text":"Spring Securityhttps://github.com/lenve/spring-security-samples 依赖使用springboot进行版本管理 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 主要是其中的两个 添加完依赖就可以使用了,默认开启保护所有接口 默认实现会生成一个登陆页面,账号为user,密码是在控制台打印的一串UUID 和用户相关的自动化配置类在 UserDetailsServiceAutoConfiguration 里边，在该类的 getOrDeducePassword 方法中，我们看到如下一行日志： 123if (user.isPasswordGenerated()) &#123; logger.info(String.format(&quot;%n%nUsing generated security password: %s%n&quot;, user.getPassword()));&#125; 通过getPassword()可以查看具体用户名和密码 SecurityProperties中用户名是user,密码是UUID 默认isPasswordGenerated()是true 修改用户名 默认用户定义在SecurityProperties类的User静态内部类中,配置注解有spring.security前缀 1234@ConfigurationProperties(prefix = &quot;spring.security&quot;)publicclass SecurityProperties &#123; ...&#125; 所以在application.properties中添加 12spring.security.user.name=javaboyspring.security.user.password=123 在application.properties中定义的用户名密码最终是通过 set 方法注入到属性中去的，查看SecurityProperties.User#setPassword 方法 1234567public void setPassword(String password) &#123; if (!StringUtils.hasLength(password)) &#123; return; &#125; this.passwordGenerated = false; this.password = password;&#125; 从这里我们可以看到，application.properties 中定义的密码在注入进来之后，还顺便设置了 passwordGenerated 属性为 false，这个属性设置为 false 之后，控制台就不会打印默认的密码了。 内存存储的用户方式1 123456789101112@Configurationpublicclass SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.inMemoryAuthentication() .withUser(&quot;user&quot;) .password(&quot;123&quot;).roles(&quot;user&quot;) .and() .withUser(&quot;admin&quot;) .password(&quot;admin&quot;).roles(&quot;USER&quot;,&quot;ADMIN&quot;); &#125;&#125; 首先我们自定义 SecurityConfig 继承自 WebSecurityConfigurerAdapter，重写 configure 方法。 configure 方法中，我们通过 inMemoryAuthentication 来开启在内存中定义用户，withUser 中是用户名，password 中则是用户密码，roles 中是用户角色。 配置多个用户，用 and 相连 方式2由于 Spring Security 支持多种数据源，例如内存、数据库、LDAP 等，这些不同来源的数据被共同封装成了一个 UserDetailService 接口，任何实现了该接口的对象都可以作为认证数据源。可以通过重写 WebSecurityConfigurerAdapter 中的 userDetailsService 方法来提供一个 UserDetailService 实例进而配置多个用户： 1234567@Beanprotected UserDetailsService userDetailsService() &#123; InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager(); manager.createUser(User.withUsername(&quot;javaboy&quot;).password(&quot;123&quot;).roles(&quot;admin&quot;).build()); manager.createUser(User.withUsername(&quot;江南一点雨&quot;).password(&quot;123&quot;).roles(&quot;user&quot;).build()); return manager;&#125; BCryptPasswordEncoder加密官方推荐使用BCryptPasswordEncoder,使用 BCrypt 强哈希函数 使用时可以选择提供 strength 和 SecureRandom 实例。 strength 越大，密钥的迭代次数越多，密钥迭代次数为 2^strength。strength 取值在 4~31 之间，默认为 10。 SecureRandom 生成加密强随机数 自带盐值 PasswordEncoder1234567publicinterface PasswordEncoder &#123; String encode(CharSequence rawPassword); boolean matches(CharSequence rawPassword, String encodedPassword); default boolean upgradeEncoding(String encodedPassword) &#123; returnfalse; &#125;&#125; encode 方法用来对明文密码进行加密，返回加密之后的密文。 matches 方法是一个密码校对方法，用户传的明文密码和数据库中保存的密文密码作为参数，传到方法中，根据返回的 Boolean 值判断是否输入正确。 upgradeEncoding 是否还要进行再次加密，这个一般来说就不用了。 使用在SecurityConfig 中 添加 PasswordEncoder 的实例 12345678@Configurationpublicclass SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Bean PasswordEncoder passwordEncoder() &#123; // return NoOpPasswordEncoder.getInstance(); //不对密码进行加密 return new BCryptPasswordEncoder(12); &#125;&#125; Spring Security 5.0 开始需要选择密码加密方式,不然会报错 配置登录页面SecurityConfig 类中重写 configure(WebSecurity web) 和 configure(HttpSecurity http) 12345678910111213141516171819@Configurationpublicclass SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override public void configure(WebSecurity web) throws Exception &#123; web.ignoring().antMatchers(&quot;/js/**&quot;, &quot;/css/**&quot;,&quot;/images/**&quot;); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .anyRequest().authenticated() .and() .formLogin() .loginPage(&quot;/login.html&quot;) .loginProcessingUrl(&quot;/login&quot;) .permitAll() .and() .csrf().disable(); &#125;&#125; web.ignoring() 用来配置忽略掉的 URL 地址，一般对于静态文件，我们可以采用此操作。 如果我们使用 XML 来配置 Spring Security ，里边会有一个重要的标签 &lt;http&gt;，HttpSecurity 提供的配置方法 都对应了该标签。 authorizeRequests 对应了 &lt;intercept-url&gt;,用于拦截url formLogin 对应了 &lt;formlogin&gt;。 loginProcessingUrl 配置了登录的请求路径 and 方法表示结束当前标签，上下文回到HttpSecurity，开启新一轮的配置。 permitAll 表示不拦截配置的接口。 关闭 csrf 配置页面 当我们定义了登录页面为 /login.html 的时,没有配置 loginProcessingUrl，Spring Security 也会帮我们自动注册一个 /login.html 的接口，用来处理登录逻辑。 FormLoginConfigurer 类 123456protected final void updateAuthenticationDefaults() &#123; if (loginProcessingUrl == null) &#123; loginProcessingUrl(loginPage); &#125; // ...&#125; 登录表单中输入框的参数默认是 username 和 password FormLoginConfigurer 类构造方法中，配置了指定变量值 12345public FormLoginConfigurer() &#123; super(new UsernamePasswordAuthenticationFilter(), null); usernameParameter(&quot;username&quot;); passwordParameter(&quot;password&quot;);&#125; 指定参数 12345678.and().formLogin().loginPage(&quot;/login.html&quot;).loginProcessingUrl(&quot;/login&quot;).usernameParameter(&quot;name&quot;).passwordParameter(&quot;passwd&quot;).permitAll().and() 注意修改前端页面 input 的 name 属性值和服务端的对应。 登录回调分为 前后端分离登录 和 前后端不分登录 前后端分离登录在前后端分离这样的开发架构下，前后端的交互都是通过 JSON 来进行，无论登录成功还是失败，都不会有什么服务端跳转或者客户端跳转之类。前端收到了登录结果,根据结果进行判断,然后跳转 登录数据保存状态无状态登录 session 是有状态服务，即服务端需要记录每次会话的客户端信息，从而识别客户端身份，根据用户身份进行请求的处理 例如登录：用户登录后，我们把用户的信息保存在服务端 session 中，并且给用户一个 cookie 值，记录对应的 session，然后下次请求，用户携带 cookie 值来（这一步有浏览器自动完成），我们就能识别到对应 session，从而找到用户的信息。 缺点: 服务端保存大量数据，增加服务端压力 服务端保存用户状态，不支持集群化部署 无状态登录 jwt 微服务集群中的每个服务，对外提供的都使用 RESTful 风格的接口。而 RESTful 风格的一个最重要的规范就是：服务的无状态性，即： 服务端不保存任何客户端请求者信息 客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份 好处 客户端请求不依赖服务端的信息，多次请求不需要必须访问到同一台服务器 服务端的集群和状态对客户端透明 服务端可以任意的迁移和伸缩（可以方便的进行集群化部署） 减小服务端存储压力 实现无状态登录 首先客户端发送账户名/密码到服务端进行认证 认证通过后，服务端将用户信息加密并且编码成一个 token，返回给客户端 以后客户端每次发送请求，都需要携带认证的 token 服务端对客户端发送来的 token 进行解密，判断是否有效，并且获取用户登录信息 登录成功使用successHandler 12345678.successHandler((req, resp, authentication) -&gt; &#123; Object principal = authentication.getPrincipal(); resp.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter out = resp.getWriter(); out.write(new ObjectMapper().writeValueAsString(principal)); out.flush(); out.close();&#125;) successHandler 方法的参数是一个 AuthenticationSuccessHandler 对象，这个对象中我们要实现的方法是 onAuthenticationSuccess。 onAuthenticationSuccess 方法有三个参数，分别是： HttpServletRequest HttpServletResponse Authentication 有了前两个参数，我们就可以在这里随心所欲的返回数据了。利用 HttpServletRequest 我们可以做服务端跳转，利用 HttpServletResponse 我们可以做客户端跳转，当然，也可以返回 JSON 数据。 第三个 Authentication 参数则保存了我们刚刚登录成功的用户信息。 登录失败失败的回调 AuthenticationFailureHandler 也是三个参数，前两个就不用说了，第三个是一个 Exception，对于登录失败，会有不同的原因，Exception 中则保存了登录失败的原因，我们可以将之通过 JSON 返回到前端。 12345678910111213141516171819.failureHandler((req, resp, e) -&gt; &#123; resp.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter out = resp.getWriter(); RespBean respBean = RespBean.error(e.getMessage()); if (e instanceof LockedException) &#123; respBean.setMsg(&quot;账户被锁定，请联系管理员!&quot;); &#125; elseif (e instanceof CredentialsExpiredException) &#123; respBean.setMsg(&quot;密码过期，请联系管理员!&quot;); &#125; elseif (e instanceof AccountExpiredException) &#123; respBean.setMsg(&quot;账户过期，请联系管理员!&quot;); &#125; elseif (e instanceof DisabledException) &#123; respBean.setMsg(&quot;账户被禁用，请联系管理员!&quot;); &#125; elseif (e instanceof BadCredentialsException) &#123; respBean.setMsg(&quot;用户名或者密码输入错误，请重新输入!&quot;); &#125; out.write(new ObjectMapper().writeValueAsString(respBean)); out.flush(); out.close();&#125;) 在 Spring Security 中，用户名查找失败对应的异常是： UsernameNotFoundException 密码匹配失败对应的异常是： BadCredentialsException 但是我们在登录失败的回调中，却总是看不到 UsernameNotFoundException 异常，无论用户名还是密码输入错误，抛出的异常都是 BadCredentialsException。 未认证处理方案在前后端分离中，如果用户没有登录就访问一个需要认证后才能访问的页面，这个时候，我们不应该让用户重定向到登录页面，而是给用户一个尚未登录的提示，前端收到提示之后，再自行决定页面跳转。 要解决这个问题，就涉及到 Spring Security 中的一个接口 AuthenticationEntryPoint ，该接口有一个实现类：LoginUrlAuthenticationEntryPoint ，该类中有一个方法 commence 这个方法是用来决定到底是要重定向还是要 forward，默认情况下请求使用重定向 重写这个方法，在方法中返回 JSON 即可，不再做重定向操作 123456789.csrf().disable().exceptionHandling().authenticationEntryPoint((req, resp, authException) -&gt; &#123; resp.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter out = resp.getWriter(); out.write(&quot;尚未登录，请先登录&quot;); out.flush(); out.close(); &#125;); 在 Spring Security 的配置中加上自定义的 AuthenticationEntryPoint 处理方法，该方法中直接返回相应的 JSON 提示即可。这样，如果用户再去直接访问一个需要认证之后才可以访问的请求，就不会发生重定向操作了，服务端会直接给浏览器一个 JSON 提示，浏览器收到 JSON 之后，该干嘛干嘛。 注销登录前后端分离项目，注销登录成功后返回 JSON 即可 123456789101112.and().logout().logoutUrl(&quot;/logout&quot;).logoutSuccessHandler((req, resp, authentication) -&gt; &#123; resp.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter out = resp.getWriter(); out.write(&quot;注销成功&quot;); out.flush(); out.close();&#125;).permitAll().and() 前后端不分离登录登录成功回调登录成功重定向 URL 相关的方法有两个,配置时只需要配置一个即可 defaultSuccessUrl defaultSuccessUrl 有一个重载的方法，我们先说一个参数的 defaultSuccessUrl 方法。如果我们在 defaultSuccessUrl 中指定登录成功的跳转页面为 /index，此时分两种情况，如果你是直接在浏览器中输入的登录地址，登录成功后，就直接跳转到 /index，如果你是在浏览器中输入了其他地址，例如 http://localhost:8080/hello，结果因为没有登录，又重定向到登录页面，此时登录成功后，就不会来到 /index ，而是来到 /hello 页面。 defaultSuccessUrl 还有一个重载的方法，第二个参数如果不设置默认为 false，也就是我们上面的的情况，如果手动设置第二个参数为 true，则 defaultSuccessUrl 的效果和 successForwardUrl 一致。 successForwardUrl successForwardUrl 表示不管你是从哪里来的，登录后一律跳转到 successForwardUrl 指定的地址。例如 successForwardUrl 指定的地址为 /index ，你在浏览器地址栏输入 http://localhost:8080/hello，结果因为没有登录，重定向到登录页面，当你登录成功之后，就会服务端跳转到 /index 页面；或者你直接就在浏览器输入了登录页面地址，登录成功后也是来到 /index。 12345678910.and().formLogin().loginPage(&quot;/login.html&quot;).loginProcessingUrl(&quot;/doLogin&quot;).usernameParameter(&quot;name&quot;).passwordParameter(&quot;passwd&quot;).defaultSuccessUrl(&quot;/index&quot;) // 只需要配置一个// .successForwardUrl(&quot;/index&quot;) // 只需要配置一个.permitAll().and() 登录失败回调与登录成功相似，登录失败也是有两个方法,配置时只需要配置一个即可 failureUrl : 在登录失败之后，会发生重定向。 failureForwardUrl : 登录失败之后会发生服务端跳转 注销登录注销登录的默认接口是 /logout，我们也可以配置。 12345678910.and().logout().logoutUrl(&quot;/logout&quot;) // 配置一个.logoutRequestMatcher(new AntPathRequestMatcher(&quot;/logout&quot;,&quot;POST&quot;)) // 配置一个.logoutSuccessUrl(&quot;/index&quot;).deleteCookies() //清除 cookie.clearAuthentication(true) //清除认证信息.invalidateHttpSession(true) //使 HttpSession 失效.permitAll().and() 默认注销的 URL 是 /logout，是一个 GET 请求，我们可以通过 logoutUrl 方法来修改默认的注销 URL。 logoutRequestMatcher 方法不仅可以修改注销 URL，还可以修改请求方式，实际项目中，这个方法和 logoutUrl 任意设置一个即可。 logoutSuccessUrl 表示注销成功后要跳转的页面。 deleteCookies 用来清除 cookie。 clearAuthentication 和 invalidateHttpSession 分别表示清除认证信息和使 HttpSession 失效，默认可以不用配置，默认就会清除。 配置权限在 Spring Security 的 configure(HttpSecurity http) 方法中配置拦截规则 1234567http.authorizeRequests() .antMatchers(&quot;&#x2F;admin&#x2F;**&quot;).hasRole(&quot;admin&quot;) .antMatchers(&quot;&#x2F;user&#x2F;**&quot;).hasRole(&quot;user&quot;) .anyRequest().authenticated() .and() ... ... 如果请求路径满足 /admin/** 格式，则用户需要具备 admin 角色。 如果请求路径满足 /user/** 格式，则用户需要具备 user 角色。 剩余的其他格式的请求路径，只需要认证（登录）后就可以访问。 使用了 Ant 风格的路径匹配符 通配符 含义 ** 匹配多层路径 * 匹配一层路径 ? 匹配任意单个字符 代码中配置的三条规则的顺序非常重要，Spring Security 在匹配的时候是按照从上往下的顺序来匹配，一旦匹配到了就不继续匹配了，「所以拦截规则的顺序不能写错」。 角色继承SecurityConfig 中添加角色继承关系 123456@BeanRoleHierarchy roleHierarchy() &#123; RoleHierarchyImpl hierarchy = new RoleHierarchyImpl(); hierarchy.setHierarchy(&quot;ROLE_admin &gt; ROLE_user&quot;); return hierarchy;&#125; 在配置时，需要给角色手动加上 ROLE_ 前缀。上面的配置表示 ROLE_admin 自动具备 ROLE_user 的权限。 使用数据库中用户信息Spring Security 支持多种不同的数据源，这些不同的数据源最终都将被封装成 UserDetailsService 的实例 UserDetailsService 的实现类中，除了 InMemoryUserDetailsManager 之外，还有一个 JdbcUserDetailsManager，使用 JdbcUserDetailsManager 可以让我们通过 JDBC 的方式将数据库和 Spring Security 连接起来。 脚本 JdbcUserDetailsManager 自己提供了一个数据库模型，这个数据库模型保存在如下位置： 1org&#x2F;springframework&#x2F;security&#x2F;core&#x2F;userdetails&#x2F;jdbc&#x2F;users.ddl 123create table users(username varchar_ignorecase(50) not null primary key,password varchar_ignorecase(500) not null,enabled boolean not null);create table authorities (username varchar_ignorecase(50) not null,authority varchar_ignorecase(50) not null,constraint fk_authorities_users foreign key(username) references users(username));create unique index ix_auth_username on authorities (username,authority); 脚本中有一种数据类型 varchar_ignorecase，这个其实是针对 HSQLDB 数据库创建的，MySQL 并不支持这种数据类型，所以需要手动调整数据类型，将 varchar_ignorecase 改为 varchar 。 执行完 SQL 脚本后，有两张表：users 和 authorities。 users 表中保存用户的基本信息，包括用户名、用户密码以及账户是否可用。 authorities 中保存了用户的角色。 authorities 和 users 通过 username 关联起来。 123456789101112131415@AutowiredDataSource dataSource;@Override@Beanprotected UserDetailsService userDetailsService() &#123; JdbcUserDetailsManager manager = new JdbcUserDetailsManager(); manager.setDataSource(dataSource); if (!manager.userExists(&quot;javaboy&quot;)) &#123; manager.createUser(User.withUsername(&quot;javaboy&quot;).password(&quot;123&quot;).roles(&quot;admin&quot;).build()); &#125; if (!manager.userExists(&quot;江南一点雨&quot;)) &#123; manager.createUser(User.withUsername(&quot;江南一点雨&quot;).password(&quot;123&quot;).roles(&quot;user&quot;).build()); &#125; return manager;&#125; 首先构建一个 JdbcUserDetailsManager 实例。 给 JdbcUserDetailsManager 实例添加一个 DataSource 对象。 调用 userExists 方法判断用户是否存在，如果不存在，就创建一个新的用户出来（因为每次项目启动时这段代码都会执行，所以加一个判断，避免重复创建用户）。 用户的创建方法和我们之前 InMemoryUserDetailsManager 中的创建方法基本一致。 这里的 createUser 或者 userExists 方法其实都是调用写好的 SQL 去判断的 如果在数据库中将用户的 enabled 属性设置为 false，表示禁用该账户，此时再使用该账户登录就会登录失败。 自定义定义用户实体类 实现 UserDetails12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Entity(name = &quot;t_user&quot;)public class User implements UserDetails &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String username; private String password; private boolean accountNonExpired; private boolean accountNonLocked; private boolean credentialsNonExpired; private boolean enabled; @ManyToMany(fetch = FetchType.EAGER,cascade = CascadeType.PERSIST) private List&lt;Role&gt; roles; @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; List&lt;SimpleGrantedAuthority&gt; authorities = new ArrayList&lt;&gt;(); for (Role role : getRoles()) &#123; authorities.add(new SimpleGrantedAuthority(role.getName())); &#125; return authorities; &#125; @Override public String getPassword() &#123; return password; &#125; @Override public String getUsername() &#123; return username; &#125; @Override public boolean isAccountNonExpired() &#123; return accountNonExpired; &#125; @Override public boolean isAccountNonLocked() &#123; return accountNonLocked; &#125; @Override public boolean isCredentialsNonExpired() &#123; return credentialsNonExpired; &#125; @Override public boolean isEnabled() &#123; return enabled; &#125; //省略其他 get/set 方法&#125; 定义 UserService 实现 UserDetailsService实现该接口，就要实现接口中的方法，也就是 loadUserByUsername ，这个方法的参数就是用户在登录的时候传入的用户名，根据用户名去查询用户信息（查出来之后，系统会自动进行密码比对）。 12345678910111213@Servicepublic class UserService implements UserDetailsService &#123; @Autowired UserDao userDao; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; User user = userDao.findUserByUsername(username); if (user == null) &#123; throw new UsernameNotFoundException(&quot;用户不存在&quot;); &#125; return user; &#125;&#125; 在 SecurityConfig 中配置用户123456@AutowiredUserService userService;@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(userService);&#125; 自动登录功能rememberMeSpring Security 中添加 .rememberMe() 123456789101112@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .anyRequest().authenticated() .and() .formLogin() .and() .rememberMe()// .key(&quot;javaboy&quot;) .and() .csrf().disable();&#125; 默认的登录页面多了一个选项，就是记住我。我们输入用户名密码，并且勾选上记住我这个框，然后点击登录按钮执行登录操作 登录数据中，除了 username 和 password 之外，还有一个 remember-me 登录成功之后，就会增加 cookie cookie是 Base64 加密的数据 1javaboy:1589104055373:2578ffbc26485c534a2ef929ac2efc47 第一段是用户名 第二段是一个两周后的时间戳 第三段是使用 MD5 散列函数算出来的值，他的明文格式是 username + &quot;:&quot; + tokenExpiryTime + &quot;:&quot; + password + &quot;:&quot; + key，最后的 key 是一个散列盐值，可以用来防治令牌被修改。 登录流程 在浏览器关闭后，并重新打开之后，用户再去访问 hello 接口，此时会携带着 cookie 中的 remember-me 到服务端，服务到拿到值之后，可以方便的计算出用户名和过期时间，再根据用户名查询到用户密码，然后通过 MD5 散列函数计算出散列值，再将计算出的散列值和浏览器传递来的散列值进行对比，就能确认这个令牌是否有效。 源码位置 令牌生成的过程 TokenBasedRememberMeServices#onLoginSuccess 首先从登录成功的 Authentication 中提取出用户名/密码。 由于登录成功之后，密码可能被擦除了，所以，如果一开始没有拿到密码，就再从 UserDetailsService 中重新加载用户并重新获取密码。 再接下来去获取令牌的有效期，令牌有效期默认就是两周。 再接下来调用 makeTokenSignature 方法去计算散列值，实际上就是根据 username、令牌有效期以及 password、key 一起计算一个散列值。如果我们没有自己去设置这个 key，默认是在 RememberMeConfigurer#getKey 方法中进行设置的，它的值是一个 UUID 字符串。 最后，将用户名、令牌有效期以及计算得到的散列值放入 Cookie 中。 问题由于我们自己没有设置 key，key 默认值是一个 UUID 字符串，这样会带来一个问题，就是如果服务端重启，这个 key 会变，这样就导致之前派发出去的所有 remember-me 自动登录令牌失效，所以，我们可以指定这个 key。指定方式如下： 123456789101112@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .anyRequest().authenticated() .and() .formLogin() .and() .rememberMe() .key(&quot;javaboy&quot;) .and() .csrf().disable();&#125; 解析的过程 提取出 cookie 信息，并对 cookie 信息进行解码，解码之后，再调用 processAutoLoginCookie 方法去做校验，processAutoLoginCookie 方法的代码我就不贴了，核心流程就是首先获取用户名和过期时间，再根据用户名查询到用户密码，然后通过 MD5 散列函数计算出散列值，再将拿到的散列值和浏览器传递来的散列值进行对比，就能确认这个令牌是否有效，进而确认登录是否有效。 持久化令牌持久化令牌就是在基本的自动登录功能基础上，又增加了新的校验参数，来提高系统的安全性，这一些都是由开发者在后台完成的，对于用户来说，登录体验和普通的自动登录体验是一样的。 在持久化令牌中，新增了两个经过 MD5 散列函数计算的校验参数，一个是 series，另一个是 token。 series 只有当用户在使用用户名/密码登录时，才会生成或者更新 token 只要有新的会话，就会重新生成，这样就可以避免一个用户同时在多端登录， 持久化令牌的具体处理类在PersistentTokenBasedRememberMeServices 类中进行具体处理","categories":[{"name":"java","slug":"java","permalink":"http://wajj.xin/categories/java/"},{"name":"Spring Security","slug":"java/Spring-Security","permalink":"http://wajj.xin/categories/java/Spring-Security/"},{"name":"SpringBoot","slug":"java/Spring-Security/SpringBoot","permalink":"http://wajj.xin/categories/java/Spring-Security/SpringBoot/"}],"tags":[{"name":"java","slug":"java","permalink":"http://wajj.xin/tags/java/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"http://wajj.xin/tags/Spring-Security/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://wajj.xin/tags/SpringBoot/"}]},{"title":"mybatis-plus","slug":"java/mybatis/mybatis-plus","date":"2021-04-11T12:51:41.000Z","updated":"2021-04-19T07:20:11.020Z","comments":true,"path":"2021/04/11/java/mybatis/mybatis-plus/","link":"","permalink":"http://wajj.xin/2021/04/11/java/mybatis/mybatis-plus/","excerpt":"","text":"mybatis-plus简化mybatis开发,对mybatis进行增强,不进行改变 特性 无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑 损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作 强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求 支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错 支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题 支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作 支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ） 内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用 内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询 分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库 内置性能分析插件：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询 内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作 依赖123456789101112131415&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 不要同时导入mybatis和mybatis-plus 使用 编写Dao,继承BaseMapper 继承了 BaseMapper 就完成了基本的crud 添加 @Mapper 或者 @Repository 表示为 Dao 层 添加启动类扫描 Mapper 包下的所有接口 @MapperScan(“com.wxy.dao”) 配置日志控制台打印: 123mybatis-plus: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl 方法查询单个查询 selectById() selectOne() 查询多个 selectBatchIds(Arrays.asList(1,2,3)) selectList() 条件查询 selectByMap() 通过map自定义查询条件 分页查询 编写分页插件配置 12345678910111213141516171819202122232425package com.wxy.config.mybatisPlus;import org.mybatis.spring.annotation.MapperScan;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.transaction.annotation.EnableTransactionManagement;import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;@EnableTransactionManagement@Configurationpublic class MyBatisPlusConfig &#123; @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() &#123; final MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor(); //分页配置 mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor()); return mybatisPlusInterceptor; &#125;&#125; 使用 123456public void testpage()&#123; Page&lt;User&gt; page = new Page&lt;&gt;(1,5); userMapper.selectPage(page,null); page.getRecords().forEach(System.out::println);&#125; 删除 deleteById() deleteByMap() deleteBatchId(Arrays.asList(1,2,3)) 逻辑删除 添加 deleted 字段 实体类中添加注解 @TableLogic 逻辑删除注解 配置逻辑删除组件 123456mybatis-plus: global-config: db-config: logic-delete-field: deleted # 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2) logic-delete-value: 1 # 逻辑已删除值(默认为 1) logic-not-delete-value: 0 # 逻辑未删除值(默认为 0) 插入insert自动生成全局唯一id并回填 主键生成策略分布式系统唯一ID生成方案汇总 默认 ID_WORKER 全局唯一ID @TableId(type = IdType.ID_WORKER ) 雪花算法Twitter开源的分布式ID生成算法,结果是long型的. 使用41bit作为毫秒数,10bit作为机器ID(5bit数据中心,5bit机器ID),12bit作为毫秒内的流水号(每个节点每毫秒可以产生4096个ID),1bit符号为(永远为0) 主键自增 @TableId(type = IdType.AUTO) 实体类上添加 @TableId(type = IdType.AUTO) 注解 数据库字段是自增的 值 描述 AUTO 数据库自增(mysql) NONE 无主键ID INPUT 自定义输入 ASSIGN_ID 雪花算法,主键可以是Long,Integer,String类型 ASSIGN_UUID 不含中划线的UUID,主键是String类型 更新updateById() 通过条件自动动态配置sql,参数是对应的对象 自动填充 数据库 在表中新增字段 create_time update_time ,设置默认值(CURRENT_TIMESTAMP) 代码 实体类的字段上添加注解 @TableField(fill = FieldFill.INSERT) //在新增时进行填充 @TableField(fill = FieldFill.INSERT_UPDATE) //在新增和修改时进行填充 … 编写处理器处理注解 1234567891011121314151617181920212223import java.util.Date;import org.apache.ibatis.reflection.MetaObject;import org.springframework.stereotype.Component;import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;@Componentpublic class MyMetaObjectHandler implements MetaObjectHandler &#123; @Override public void insertFill(final MetaObject metaObject) &#123; this.setFieldValByName(&quot;createTime&quot;, new Date(), metaObject); this.setFieldValByName(&quot;updateTime&quot;, new Date(), metaObject); &#125; @Override public void updateFill(final MetaObject metaObject) &#123; this.setFieldValByName(&quot;updateTime&quot;, new Date(), metaObject); &#125;&#125; 乐观锁乐观锁 : 认为不会出现问题,无论干什么都不会加锁.如果出问题,再次更新 悲观锁 : 认为总是会出现问题,无论干什么都会去加锁,然后去操作 乐观锁实现方式： 取出记录时，获取当前 version 更新时，带上这个version 执行更新时， set version = newVersion where version = oldVersion 如果version不对，就更新失败 MP操作 添加 version 字段,默认值为 1 实体类添加对应字段,添加 @Version 乐观锁注解 注册组件 123456789101112131415161718192021222324package com.wxy.config.mybatisPlus;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.transaction.annotation.EnableTransactionManagement;import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;@EnableTransactionManagement@Configurationpublic class MyBatisPlusConfig &#123; @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() &#123; final MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor(); //乐观锁 mybatisPlusInterceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor()); return mybatisPlusInterceptor; &#125;&#125; 测试 1234567891011// 测试乐观锁成功！@Test public void testOptimisticLocker()&#123; // 1、查询用户信息 User user = userMapper.selectById(1L); // 2、修改用户信息 user.setName(&quot;kuangshen&quot;); user.setEmail(&quot;24736743@qq.com&quot;); // 3、执行更新操作 userMapper.updateById(user); &#125; 12345678910111213141516171819// 测试乐观锁失败！多线程下 @Test public void testOptimisticLocker2()&#123; // 线程 1 User user = userMapper.selectById(1L); user.setName(&quot;kuangshen111&quot;); user.setEmail(&quot;24736743@qq.com&quot;); // 模拟另外一个线程执行了插队操作 User user2 = userMapper.selectById(1L); user2.setName(&quot;kuangshen222&quot;); user2.setEmail(&quot;24736743@qq.com&quot;); userMapper.updateById(user2); // 自旋锁来多次尝试提交！ userMapper.updateById(user); // 如果没有乐观锁就会覆盖插队线程的值！&#125; 条件构造器Wrapper QueryWrapper LambdaQueryWrapper UpdateWrapper LambdaUpdateWrapper 方法 说明 ge 大于等于 gt 大于 le 小于等于 lt 小于 isNull 空 isNotNull 不为空 方法 说明 allEq 全eq eq 等于 = ne 不等于 &lt;&gt; 方法 说明 例子 between BETWEEN 值1 AND 值2 between(“age”, 18, 30) notBetween NOT BETWEEN 值1 AND 值2 方法 说明 like LIKE ‘%值%’ notlike NOT LIKE ‘%值%’ likeLeft LIKE ‘%值’ likeRight LIKE ‘值%’ 性能分析插件 添加插件 123456789/** * SQL执行效率插件 */@Bean @Profile(&#123;&quot;dev&quot;,&quot;test&quot;&#125;)// 设置 dev test 环境开启，保证我们的效率 public PerformanceInterceptor performanceInterceptor() &#123; PerformanceInterceptor performanceInterceptor = new PerformanceInterceptor(); performanceInterceptor.setMaxTime(100); // ms设置sql执行的最大时间，如果超过了则不 执行 performanceInterceptor.setFormat(true); // 是否格式化代码 return performanceInterceptor;&#125; 执行sql,执行时间超过限定会抛出异常 新版已更换为 p6spy 代码自动生成依赖 123456789101112131415161718192021222324&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt; &lt;version&gt;2.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-extension&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt;&lt;/dependency&gt; 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import java.util.ArrayList;import com.baomidou.mybatisplus.annotation.DbType;import com.baomidou.mybatisplus.annotation.FieldFill;import com.baomidou.mybatisplus.annotation.IdType;import com.baomidou.mybatisplus.generator.AutoGenerator;import com.baomidou.mybatisplus.generator.config.DataSourceConfig;import com.baomidou.mybatisplus.generator.config.GlobalConfig;import com.baomidou.mybatisplus.generator.config.PackageConfig;import com.baomidou.mybatisplus.generator.config.StrategyConfig;import com.baomidou.mybatisplus.generator.config.po.TableFill;import com.baomidou.mybatisplus.generator.config.rules.DateType;import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;// 代码自动生成器public class CodeGenerator &#123; public static void main(final String[] args) &#123; // 需要构建一个 代码自动生成器 对象 final AutoGenerator mpg = new AutoGenerator(); // 配置策略 // 1、全局配置 final GlobalConfig gc = new GlobalConfig(); final String projectPath = System.getProperty(&quot;user.dir&quot;); gc.setOutputDir(projectPath + &quot;/demo/src/main/java&quot;); gc.setAuthor(&quot;abc&quot;); // 是否打开输出目录 gc.setOpen(false); // 是否覆盖 gc.setFileOverride(true); // 去Service的I前缀 gc.setServiceName(&quot;%sService&quot;); gc.setMapperName(&quot;%sDao&quot;); gc.setIdType(IdType.AUTO); gc.setDateType(DateType.ONLY_DATE); gc.setSwagger2(true); mpg.setGlobalConfig(gc); //2、设置数据源 final DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl( &quot;jdbc:mysql://localhost:3306/abbbb? useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8&quot;); dsc.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;); dsc.setUsername(&quot;root&quot;); dsc.setPassword(&quot;123&quot;); dsc.setDbType(DbType.MYSQL); mpg.setDataSource(dsc); //3、包的配置 final PackageConfig pc = new PackageConfig(); //只需要改实体类名字 和包名 还有 数据库配置即可 pc.setModuleName(&quot;cat&quot;); pc.setParent(&quot;com.abc&quot;); pc.setEntity(&quot;model.entity&quot;); pc.setMapper(&quot;dao&quot;); pc.setService(&quot;service&quot;); pc.setController(&quot;controller&quot;); mpg.setPackageInfo(pc); //4、策略配置 final StrategyConfig strategy = new StrategyConfig(); strategy.setInclude(&quot;表名1&quot;,&quot;表名2&quot;); // 设置要映射的表名驼峰命名 strategy.setNaming(NamingStrategy.underline_to_camel); strategy.setColumnNaming(NamingStrategy.underline_to_camel); // 自动lombok； strategy.setEntityLombokModel(true); // 配置逻辑删除 strategy.setLogicDeleteFieldName(&quot;deleted&quot;); // 自动填充配置 final TableFill gmtCreate = new TableFill(&quot;create_time&quot;, FieldFill.INSERT); final TableFill gmtModified = new TableFill(&quot;update_time&quot;, FieldFill.INSERT_UPDATE); final ArrayList&lt;TableFill&gt; tableFills = new ArrayList&lt;&gt;(); tableFills.add(gmtCreate); tableFills.add(gmtModified); strategy.setTableFillList(tableFills); // 乐观锁 strategy.setVersionFieldName(&quot;version&quot;); strategy.setRestControllerStyle(true); // 驼峰转连字符 abc/hello_id // strategy.setControllerMappingHyphenStyle(true); mpg.setStrategy(strategy); mpg.execute(); //执行 &#125;&#125; mybatis-generator依赖 12345678910111213141516171819202122232425&lt;build&gt; &lt;plugins&gt; &lt;!--mybatis generator--&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt; &lt;configuration&gt; &lt;!-- 在控制台打印执行日志 --&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;!-- 重复生成时会覆盖之前的文件--&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;configurationFile&gt;src/main/resources/generatorConfig.xml&lt;/configurationFile&gt; &lt;/configuration&gt; &lt;!-- 数据库连接选择8.0以上的，因为用的mysql8.0--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;!-- targetRuntime：设置生成的文件适用于那个 mybatis 版本 --&gt; &lt;context id=&quot;default&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;!--optional,指在创建class时，对注释进行控制--&gt; &lt;commentGenerator&gt; &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt; &lt;/commentGenerator&gt; &lt;!--jdbc的数据库连接 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/abc?useUnicode=true&amp;amp;characeterEncoding=utf-8&amp;amp;serverTimezone=UTC&quot; userId=&quot;root&quot; password=&quot;root&quot;&gt; &lt;/jdbcConnection&gt; &lt;!--非必须，类型处理器，在数据库类型和java类型之间的转换控制--&gt; &lt;javaTypeResolver&gt; &lt;!-- 默认情况下数据库中的 decimal，bigInt 在 Java 对应是 sql 下的 BigDecimal 类 --&gt; &lt;!-- 不是 double 和 long 类型 --&gt; &lt;!-- 使用常用的基本类型代替 sql 包下的引用类型 --&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt; &lt;/javaTypeResolver&gt; &lt;!-- targetPackage：生成的实体类所在的包 --&gt; &lt;!-- targetProject：生成的实体类所在的硬盘位置 --&gt; &lt;javaModelGenerator targetPackage=&quot;com.abc.model.entity&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;!-- 是否允许子包 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt; &lt;!-- 是否清理从数据库中查询出的字符串左右两边的空白字符 --&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt; &lt;/javaModelGenerator&gt; &lt;!-- targetPackage 和 targetProject：生成的 mapper 文件的包和位置 --&gt; &lt;sqlMapGenerator targetPackage=&quot;/mapper/abc&quot; targetProject=&quot;src/main/resources&quot;&gt; &lt;!-- 针对数据库的一个配置，是否把 schema 作为字包名 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- targetPackage 和 targetProject：生成的 interface 文件的包和位置 --&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.abc.dao&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;!-- 针对 oracle 数据库的一个配置，是否把 schema 作为字包名 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt; &lt;/javaClientGenerator&gt; &lt;!-- &lt;table tableName=&quot;%&quot; schema=&quot;abc&quot;--&gt; &lt;!-- enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot;--&gt; &lt;!-- enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot;--&gt; &lt;!-- selectByExampleQueryId=&quot;false&quot;/&gt;--&gt; &lt;!-- tableName是数据库中的表名，domainObjectName是生成的JAVA模型名，后面的参数不用改，要生成更多的表就在下面继续加table标签 --&gt; &lt;table tableName=&quot;abc&quot; domainObjectName=&quot;abc&quot; enableInsert=&quot;true&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt; &lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt;","categories":[{"name":"java","slug":"java","permalink":"http://wajj.xin/categories/java/"},{"name":"mybatis","slug":"java/mybatis","permalink":"http://wajj.xin/categories/java/mybatis/"}],"tags":[{"name":"java","slug":"java","permalink":"http://wajj.xin/tags/java/"},{"name":"mybatis","slug":"mybatis","permalink":"http://wajj.xin/tags/mybatis/"}]}],"categories":[{"name":"DOM","slug":"DOM","permalink":"http://wajj.xin/categories/DOM/"},{"name":"Gradle","slug":"Gradle","permalink":"http://wajj.xin/categories/Gradle/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://wajj.xin/categories/JavaScript/"},{"name":"Java8","slug":"Java8","permalink":"http://wajj.xin/categories/Java8/"},{"name":"Java","slug":"Java","permalink":"http://wajj.xin/categories/Java/"},{"name":"技巧","slug":"技巧","permalink":"http://wajj.xin/categories/%E6%8A%80%E5%B7%A7/"},{"name":"java","slug":"java","permalink":"http://wajj.xin/categories/java/"},{"name":"Quartz","slug":"java/Quartz","permalink":"http://wajj.xin/categories/java/Quartz/"},{"name":"Linux","slug":"Linux","permalink":"http://wajj.xin/categories/Linux/"},{"name":"nginx","slug":"Linux/nginx","permalink":"http://wajj.xin/categories/Linux/nginx/"},{"name":"数据库","slug":"数据库","permalink":"http://wajj.xin/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"mysql","slug":"mysql","permalink":"http://wajj.xin/categories/mysql/"},{"name":"Spring Security","slug":"java/Spring-Security","permalink":"http://wajj.xin/categories/java/Spring-Security/"},{"name":"SpringBoot","slug":"java/Spring-Security/SpringBoot","permalink":"http://wajj.xin/categories/java/Spring-Security/SpringBoot/"},{"name":"mybatis","slug":"java/mybatis","permalink":"http://wajj.xin/categories/java/mybatis/"}],"tags":[{"name":"DOM","slug":"DOM","permalink":"http://wajj.xin/tags/DOM/"},{"name":"Gradle","slug":"Gradle","permalink":"http://wajj.xin/tags/Gradle/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://wajj.xin/tags/JavaScript/"},{"name":"Lambda","slug":"Lambda","permalink":"http://wajj.xin/tags/Lambda/"},{"name":"Java8","slug":"Java8","permalink":"http://wajj.xin/tags/Java8/"},{"name":"abbb","slug":"abbb","permalink":"http://wajj.xin/tags/abbb/"},{"name":"DateTimeFormatter","slug":"DateTimeFormatter","permalink":"http://wajj.xin/tags/DateTimeFormatter/"},{"name":"stream","slug":"stream","permalink":"http://wajj.xin/tags/stream/"},{"name":"vo","slug":"vo","permalink":"http://wajj.xin/tags/vo/"},{"name":"do","slug":"do","permalink":"http://wajj.xin/tags/do/"},{"name":"技巧","slug":"技巧","permalink":"http://wajj.xin/tags/%E6%8A%80%E5%B7%A7/"},{"name":"JRebel","slug":"JRebel","permalink":"http://wajj.xin/tags/JRebel/"},{"name":"java","slug":"java","permalink":"http://wajj.xin/tags/java/"},{"name":"Quartz","slug":"Quartz","permalink":"http://wajj.xin/tags/Quartz/"},{"name":"Linux","slug":"Linux","permalink":"http://wajj.xin/tags/Linux/"},{"name":"nginx","slug":"nginx","permalink":"http://wajj.xin/tags/nginx/"},{"name":"数据库设计","slug":"数据库设计","permalink":"http://wajj.xin/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"},{"name":"mysql","slug":"mysql","permalink":"http://wajj.xin/tags/mysql/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"http://wajj.xin/tags/Spring-Security/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://wajj.xin/tags/SpringBoot/"},{"name":"mybatis","slug":"mybatis","permalink":"http://wajj.xin/tags/mybatis/"}]}